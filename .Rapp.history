head(posteriors)
jpeg("figures/figure_4.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)#
library(ggplot2)#
library(tidyverse)#
library(viridis)#
library(coda)
#load posterior samples#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.April302019.mcmc")#
posteriors = as.matrix(sr_model.mcmc, chain=F)
# set number of simulations and create array to store results #
num.sims = 1#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}
alpha
beta
Ro
l
w
draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi
out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)
lst.resid
process.iteration(posteriors[draw,])$last_resid
phi
Spw
Rec
mat
sigma.R
samp <- posteriors[draw,]
nms = names(samp)
nms
# parameters#
  alpha = unname(samp[substr(nms, 1, 5) == "alpha"])#
  beta = unname(samp[substr(nms, 1, 5) == "beta"])#
  last_resid = unname(samp[substr(nms, 1, 13) == "log.resid.40."])
last_resid
unname(samp[substr(nms, 1, 13) == "log.resid.40."])
head(posteriors)
nms
as.numeric(samp["S.40."])
samp["S.40."]
posteriors <- sr_model.mcmc
num.sims = 1#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}
posteriors = as.matrix(sr_model.mcmc, chain=F)
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)
samp()
samp(posteriors[draw,])
samp(posteriors[1,])
samp<-(posteriors[1,])
nms = names(samp)
nms
last_resid = unname(samp[substr(nms, 1, 14) == "log.resid.40."])
last_resid
last_resid = unname(samp[substr(nms, 1, 12) == "log.resid.40."])
last_resid
substr(nms, 1, 13) == "log.resid.40."
substr(nms, 1, 5) == "alpha"
substr(nms, 1, 5) == "beta"]
substr(nms, 1, 5) == "beta"
substr(nms, 1, 13) == "log.resid.40."
substr(nms, 1) == "log.resid.40."
substr(nms, 1,15) == "log.resid.40."
substr(nms, 1,20) == "log.resid.40."
substr(nms, 1,20) == "log.resid.1."
substr(nms, 1, 8) == "beta"
samp["pi.2."]
nms
last_resid = unname(samp[substr(nms, 1, 13) == "log.resid[40]"])
last_resid
mat.sch = c(as.numeric(samp["pi[1]"]), as.numeric(samp["pi[2]"]), as.numeric(samp["pi[3]"]), as.numeric(samp["pi[4]"]))
mat.sch
S = c(as.numeric(samp["S[40]"]), as.numeric(samp["S[41]"]), as.numeric(samp["S[42]"]), as.numeric(samp["S[43]"]))
S
## Functions for analysis#
#
#------------------------------------------------------------------------------##
# Posterior summary function#
#------------------------------------------------------------------------------##
post.summ = function(post.samp, var) {#
  post.samp = as.matrix(post.samp)#
  # if parameter is indexed#
  if(substr(var, nchar(var), nchar(var)) == "[") {#
    post = post.samp[,substr(colnames(post.samp), 1, nchar(var)) == var]#
    summ = apply(post, 2, function(x) c(mean = mean(x), sd = sd(x), quantile(x, c(0.5, 0.025, 0.975, 0.1, 0.9, 0.2, 0.8, 0.3, 0.7))))#
    return(summ)#
  }#
  # if parameter is not indexed#
  if(substr(var, nchar(var), nchar(var)) != "[") {#
    post = post.samp[,substr(colnames(post.samp), 1, nchar(var)) == var]#
    summ = c(mean = mean(post), sd = sd(post), quantile(post, c(0.5, 0.025, 0.975)))#
    return(summ)#
  }#
}#
#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years#
# Ro <- the sub-stock recruiment at time zero#
# phi <- the expected correlation through time#
# mat <- stock-specific maturation schedules#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density depedence #
# sigma.R <- recruitment variation#
# U <- finite annual exploitation rate#
# pm.yr <- year of simulation that pms start to be calculated over#
# Rec <- estimated recruitments from last years of empirical data #
# Spw <- estimated spawers from last years of empirical data#
# lst.resid <- estimated recruitment deviation from last year of empirical data#
#
process = function(ny,Ro,phi,mat,U,alpha,beta,sigma.R,Rec,Spw,lst.resid){#
	ns = length(Ro) #number of sub-stocks#
	m.alpha <- alpha#
	m.beta <- beta#
	epi = rnorm(ny, sd= sigma.R)#
#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(0,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	#R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	R[1:3,]=Rec#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot; S = Ntot#
	S[4:7,] = Spw#
	predR = Ntot#
	# populate first few years with realized states#
	R[4,] = exp(log(alpha[]*S[4,]*exp(-beta[]*S[4,])) + phi* lst.resid) * exp(epi[4])#
	v[4,] = log(R[4,])-log(alpha[]*S[4,]*exp(-beta[]*S[4,]))#
	for(i in 5:7){#
		R[i,] = exp(log(alpha[]*S[i,]*exp(-beta[]*S[i,])) + phi* v[i-1,]) * exp(epi[i])#
		v[i,] = log(R[i,])-log(alpha[]*S[i,]*exp(-beta[]*S[i,]))		#
	}#
#
	N[4:7,1,]=R[4:7-(3),] * mat[1]#
	N[5:7,2,]=R[5:7-(4),] * mat[2]#
	N[6:7,3,]=R[6:7-(5),] * mat[3]#
	N[7,4,]=R[7-(6),] * mat[4]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){ #
		N[i,1,1] = R[i-(4),1] * mat[1]#
		N[i,2,1] = R[i-(5),1] * mat[2]#
		N[i,3,1] = R[i-(6),1] * mat[3]#
		N[i,4,1] = R[i-(7),1] * mat[4]#
		Ntot[i,1] = sum(N[i,,1])#
#
		# apply harvest #
		H[i,1] =  U*Ntot[i,1]#
		S_exp = Ntot[i,1]-H[i,1] ; S_exp[S_exp<0] = 0#
		S[i,1] = S_exp#
		# predict recruitment#
		R[i,1] = alpha[]*S[i,1]*exp(-beta[]*S[i,1]+phi*v[i-1,1]+epi[i])#
		predR[i,] = alpha[]*S[i,1]*exp(-beta[]*S[i,1])#
		v[i,1] = log(R[i,1])-log(predR[i,1])#
		v[v[,1]=='NaN'] <- 0#
	    }#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	p_rg <-ifelse(median(S[(ny-10):ny,])>15000,1,0)#
	p_lrp <-ifelse(median(S[(ny-10):ny,])>4000,1,0)#
	list(S=S[,],N=Ntot[,],survival=as.numeric(v),P=c(p_rg,p_lrp))#
	}#
#
#------------------------------------------------------------------------------##
# Function to sample from posteriors for forward simulations#
#------------------------------------------------------------------------------#	#
#
process.iteration = function(samp) {#
  # 1.) extract names#
  nms = names(samp)#
  # 2.) extract elements according to the names and put them into the appropriate data structure#
  # parameters#
  alpha = unname(samp[substr(nms, 1, 5) == "alpha"])#
  beta = unname(samp[substr(nms, 1, 5) == "beta"])#
  last_resid = unname(samp[substr(nms, 1, 13) == "log.resid[40]"])#
  phi = unname(samp["phi"])#
  sigma_R = unname(samp["sigma.R"])#
  mat.sch = c(as.numeric(samp["pi[1]"]), as.numeric(samp["pi[2]"]), as.numeric(samp["pi[3]"]), as.numeric(samp["pi[4]"]))#
  # states#
  S = c(as.numeric(samp["S[40]"]), as.numeric(samp["S[41]"]), as.numeric(samp["S[42]"]), as.numeric(samp["S[43]"]))#
  R = c(as.numeric(samp["R[44]"]), as.numeric(samp["R[45]"]), as.numeric(samp["R[46]"]))#
  # 3.) create output list#
  output = list(#
    alpha = as.numeric(alpha),#
    beta = as.numeric(beta),#
    phi = as.numeric(phi),#
    last_resid = as.numeric(last_resid),#
    sigma_R = as.numeric(sigma_R),#
    mat.sch = mat.sch,#
    S = S,#
    R = R#
    )#
#
  # 4.) return output#
  return(output)#
#
}
# set number of simulations and create array to store results #
num.sims = 1#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)#
library(ggplot2)#
library(tidyverse)#
library(viridis)#
library(coda)
#------------------------------------------------------------------------------##
# Run closed loop simulations across a range of harves rates#
#------------------------------------------------------------------------------##
#
#load posterior samples#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.April302019.mcmc")#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
# set number of simulations and create array to store results #
num.sims = 1000#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}#
saveRDS(temporal.outcomes,"outputs/forward_sims_baseline.temp_out.Apr302019")  #
saveRDS(static.outcomes,"outputs/forward_sims_baseline.static_out.Apr302019")  #
(proc.time() - ptm)/60
static.outcomes
temporal.outcomes
saveRDS(temporal.outcomes,"outputs/forward_sims_baseline.temp_out.Apr302019")  #
saveRDS(static.outcomes,"outputs/forward_sims_baseline.static_out.Apr302019")
source("figure_5.R")
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.April302019.mcmc")#
posteriors = as.matrix(sr_model.mcmc, chain=F)
forward_sims <- readRDS("outputs/forward_sims_baseline.temp_out.Apr302019")#
forward_res <- readRDS("outputs/forward_sims_baseline.static_out.Apr302019")
outcomes.sims <- apply(forward_sims,c(1,2,4),quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9),na.rm=T)#
outcomes.res <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
# some housekeeping#
years <- seq(2005,2017)#
#
nms = names(posteriors)#
yy <- posteriors[substr(nms, 1, 2) == "S."]#
spw <- yy[,4:46]#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)
yy <- posteriors[substr(nms, 1, 2) == "S[]"]
spw <- yy[,4:46]
yy
nms = names(posteriors)#
yy <- posteriors[substr(nms, 1, 2) == "S["]
spw <- yy[,4:46]
yy
nms
nms = names(posteriors)
nms
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.April302019.mcmc")
posteriors = as.matrix(sr_model.mcmc, chain=F)
nms = names(posteriors)
nms
posteriors
head(posteriors)
nms = names(posteriors)
nms
nms = names(sr_model.mcmc)
nms
dimnames(posteriors)
nms = dimnames(posteriors)
nms
yy <- posteriors[substr(nms, 1, 2) == "S["]
yy
yy <- posteriors[substr(nms, 1, 3) == "S["]
yy
yy <- posteriors[substr(nms, 1, 1) == "S["]
yy
yy <- posteriors[substr(nms, 1, 2) = "S["]
yy <- posteriors[substr(nms, 1, 2) == "S["]
yy
head(posteriors)
yy <- posteriors[,593:630]
HEAD(yy)
head(yy)
spw <- posteriors[,593:630]#
#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)
head(spw)
nms
spw <- posteriors[,593:635]#
#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)
# generate plot#
jpeg("figures/Figure_5.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=2)#
ablineclip(h=4000,lty=3,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,3),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
source("figure_5.R")
source("samp_sims_figure6_7.R")
source("load.R")
source("samp_sims_figure6_7.R")
jpeg(filename = "figures/figure_6.jpeg",#
     width = 2600, height = 1500, units = "px", pointsize = 9,#
     bg = "white", res = 600)#
#
samples<-c(60,120,240,360,600)#
#
par(mfrow=c(1,2))    #
par(mar=c(2,1,1,0),oma=c(2,4,1,1))#
### single sample#
for(i in 1:10){#
  plot(comp.var[i,1:5],type="l",ylim=c(0,1.6),axes=FALSE,xlab="",ylab="",col= colors[i])#
  par(new=TRUE)#
}#
plot(comp.equal[,1],type="l",las=1,xlab="",ylab="",lwd=2,ylim=c(0,1.6),axes=FALSE)    #
#
axis(1,at=c(1,2,3,4,5),labels=samples,cex.axis=0.9)#
axis(2,las=1,at=c(0,0.5,1.0,1.5,2.0),cex.axis=0.9)#
text(2.5,1.55,"(a) annual sampling",cex=0.8)#
text(4,0.83,"smallest population",cex=0.55, col=colors[1])#
text(4,0.10,"largest population",cex=0.55, col=colors[10])#
mtext(side=2,"Catch composition",line=3.5)#
mtext(side=2,"uncertainty (CV)",adj=0.5,line=2.5)#
mtext(side=1,"Number of samples",line=0.5,outer=T)#
box(col="grey")#
#
### weekly sample#
for(i in 1:10){#
  plot(comp.var[i,6:10],type="l",ylim=c(0,1.6),axes=FALSE,xlab="",ylab="",col=colors[i])#
  par(new=TRUE)#
}#
plot(comp.equal[,2],type="l",las=1,xlab="",ylab="",lwd=2,ylim=c(0,1.6),axes=FALSE)   #
text(2.5,1.55,"(b) weekly sampling",cex=0.8)#
#
axis(1,at=c(1,2,3,4,5),labels=samples,cex.axis=0.9)#
axis(2,las=1,at=c(0,0.5,1.0,1.5,2.0),labels=FALSE)#
box(col="grey")#
#
dev.off()  #
#
##########################################################
#### plotting harvest rate data#
#
harv.equal<-matrix(nrow=5,ncol=10)#
#
rate.yr1.0#
rate.yr3.0#
#
for(i in 1:5){#
harv.equal[i,1]<-mean(rate.yr1.0[,4,i])#
harv.equal[i,2]<-mean(rate.yr3.0[,4,i])#
harv.equal[i,3]<-mean(rate.yr1.1[,4,i])#
harv.equal[i,4]<-mean(rate.yr3.1[,4,i])#
harv.equal[i,5]<-mean(rate.yr1.2[,4,i])#
harv.equal[i,6]<-mean(rate.yr3.2[,4,i])#
harv.equal[i,7]<-mean(rate.yr1.3[,4,i])#
harv.equal[i,8]<-mean(rate.yr3.3[,4,i])#
harv.equal[i,9]<-mean(rate.yr1.4[,4,i])#
harv.equal[i,10]<-mean(rate.yr3.4[,4,i])#
}#
#
harv.var<-array(dim=c(5,15,2))#
#
harv.var[,,1]                #
for(i in 1:5){#
  harv.var[i,1,1]<-rate.yr2.0[1,4,i]#
  harv.var[i,2,1]<-rate.yr2.0[9,4,i]#
  harv.var[i,3,1]<-mean(rate.yr2.0[,4,i])#
  harv.var[i,4,1]<-rate.yr2.1[1,4,i]#
  harv.var[i,5,1]<-rate.yr2.1[9,4,i]#
  harv.var[i,6,1]<-mean(rate.yr2.1[,4,i])#
  harv.var[i,7,1]<-rate.yr2.2[1,4,i]#
  harv.var[i,8,1]<-rate.yr2.2[9,4,i]#
  harv.var[i,9,1]<-mean(rate.yr2.2[,4,i])#
  harv.var[i,10,1]<-rate.yr2.3[1,4,i]#
  harv.var[i,11,1]<-rate.yr2.3[9,4,i]#
  harv.var[i,12,1]<-mean(rate.yr2.3[,4,i]) #
  harv.var[i,13,1]<-rate.yr2.4[1,4,i]#
  harv.var[i,14,1]<-rate.yr2.4[9,4,i]#
  harv.var[i,15,1]<-mean(rate.yr2.4[,4,i]) #
#
}#
for(i in 1:5){#
  harv.var[i,1,2]<-rate.yr4.0[1,4,i]#
  harv.var[i,2,2]<-rate.yr4.0[9,4,i]#
  harv.var[i,3,2]<-mean(rate.yr4.0[,4,i])#
  harv.var[i,4,2]<-rate.yr4.1[1,4,i]#
  harv.var[i,5,2]<-rate.yr4.1[9,4,i]#
  harv.var[i,6,2]<-mean(rate.yr4.1[,4,i])#
  harv.var[i,7,2]<-rate.yr4.2[1,4,i]#
  harv.var[i,8,2]<-rate.yr4.2[9,4,i]#
  harv.var[i,9,2]<-mean(rate.yr4.2[,4,i])#
  harv.var[i,10,2]<-rate.yr4.3[1,4,i]#
  harv.var[i,11,2]<-rate.yr4.3[9,4,i]#
  harv.var[i,12,2]<-mean(rate.yr4.3[,4,i]) #
  harv.var[i,13,2]<-rate.yr4.4[1,4,i]#
  harv.var[i,14,2]<-rate.yr4.4[9,4,i]#
  harv.var[i,15,2]<-mean(rate.yr4.4[,4,i]) #
}#
jpeg(filename = "figures/figure_7.jpeg",#
     width = 2400, height = 2400, units = "px", pointsize = 9,#
     bg = "white", res = 600)#
#
colors<-viridis(5)#
colors1<-viridis(3)#
colors2<-viridis(3, alpha=0.2)#
single<-c(1,3,5,7,9)#
week<-c(2,4,6,8,10)#
#
par(mfrow=c(2,2))#
par(mar=c(0,1,1,0),oma=c(4,4,1,1))#
#
for(i in 1:5){#
  plot(harv.equal[,single[i]],type="l",ylim=c(0,1.5),xlim=c(1,5),axes=FALSE,xlab="",ylab="",col=colors[i],lwd=2)#
  par(new=TRUE)#
#
}#
plot(1,cex=0,axes=FALSE,xlab="",ylab="",ylim=c(0,1.5),xlim=c(1,5))#
axis(1,at=c(1,2,3,4,5),labels=FALSE)#
axis(2,las=2,at=c(0,0.5,1,1.5,2))#
mtext(side=3,"Annual sampling", cex=1,adj=0.5)#
text(1.25,1.45,"(a)")#
mtext(side=2,"Harvest rate uncertianty (CV)",line=2.5,outer=T)#
box(col="grey")#
#
legend("topright", title="",pch=15,c("No observation error","Catch CV = 0.2; Size CV = 0.2","Catch CV = 0.2; Size CV = 0.5","Catch CV = 0.5; Size CV = 0.2","Catch CV = 0.5; Size CV = 0.5"),col=colors,cex=0.70,inset=0.03,bty="n")#
#
for(i in 1:5){#
  plot(harv.equal[,week[i]],type="l",ylim=c(0,1.5),xlim=c(1,5),axes=FALSE,xlab="",ylab="",col=colors[i],lwd=2)#
  par(new=TRUE)#
}#
plot(1,cex=0,axes=FALSE,xlab="",ylab="",ylim=c(0,1.5),xlim=c(1,5))#
axis(1,at=c(1,2,3,4,5),labels=FALSE)#
axis(2,las=2,at=c(0,0.5,1,1.5,2),labels=FALSE)#
mtext(side=3,"Weekly sampling", cex=1,adj=0.5)#
text(1.25,1.45,"(b)")#
box(col="grey")#
#
#### annual sampling variable population size#
gr<-c(1,4,13)#
#
for (i in 1:3){#
  for(j in 0:1){#
    plot(harv.var[,gr[i]+j,1],ylim=c(0,1.8),type="l",col=colors1[i],axes=FALSE,xlab="",ylab="",lty=2)#
    par(new=TRUE)#
    plot(harv.var[,gr[i]+2,1],ylim=c(0,1.8),type="l",col=colors1[i],axes=FALSE,xlab="",ylab="",lwd=2)#
    polygon(c(seq(1,5),rev(seq(1,5))),c(harv.var[,gr[i]+j,1],rev(harv.var[,gr[i]+2,1])),col=colors2[i],border=NA)#
    par(new=TRUE)#
    }#
}#
#
harv.var#
#
plot(1,cex=0,axes=FALSE,xlab="",ylab="",ylim=c(0,1.8),xlim=c(1,5))#
axis(1,at=c(1,2,3,4,5),labels=c(60,120,240,360,600))#
axis(2,las=2,at=c(0,0.5,1,1.5,2),labels=c(0,0.5,1,1.5,2))#
text(1.25,1.75,"(c)")#
mtext(side=1,"Number of samples",outer=T,line=2.5)#
box(col="grey")#
#
#### weekly sampling variable population size#
for (i in 1:3){#
  for(j in 0:1){#
    plot(harv.var[,gr[i]+j,2],ylim=c(0,1.8),type="l",col=colors1[i],axes=FALSE,xlab="",ylab="",lty=2)#
    par(new=TRUE)#
    plot(harv.var[,gr[i]+2,2],ylim=c(0,1.8),type="l",col=colors1[i],axes=FALSE,xlab="",ylab="",lwd=2)#
    polygon(c(seq(1,5),rev(seq(1,5))),c(harv.var[,gr[i]+j,2],rev(harv.var[,gr[i]+2,2])),col=colors2[i],border=NA)#
    par(new=TRUE)#
  }#
}#
#
plot(1,cex=0,axes=FALSE,xlab="",ylab="",ylim=c(0,1.8),xlim=c(1,5))#
axis(1,at=c(1,2,3,4,5),labels=c(60,120,240,360,600))#
axis(2,las=2,at=c(0,0.5,1,1.5,2),labels=FALSE)#
text(1.25,1.75,"(d)")#
box(col="grey")#
#
dev.off()
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)#
library(ggplot2)#
library(tidyverse)#
library(viridis)#
library(coda)
age = read.delim("data/AgeCompTab.txt")#
esc = read.csv("data/EscTab.csv")#
harv = read.csv("data/HarTab.csv")#
#------------------------------------------------------------------------------##
#   Set beta prior for stock (uniform (uninformative) prior can be commented#
#	out in model description (line 58)) #
#------------------------------------------------------------------------------##
SMAX <- mean(esc[,2]) # mean escapement over time series#
#SMAX <- 21300 # lake habitat (photosynthetic rate) based estimate of lake capacity#
#
bpmu = 1/SMAX # turn SMAX into beta prior#
bptau = 1/(0.3^2)  # set CV on prior#
#------------------------------------------------------------------------------##
#   Format data#
#------------------------------------------------------------------------------##
Y = nrow(age)             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
years = age[,"year"]#
# escapement: assume a 20% observation CV if directly observed, 40% otherwise#
S.cv = ifelse(esc[,3] == 0.5, 1, 0.5)#
S.obs = esc[,2]#
# harvest: assume a 15% observation CV for years when catch was high and dominated by commercial fishery, 30% in years since#
C.cv = ifelse(harv[,3] == 1, 0.15, 0.30)#
C.obs = harv[,4] # choose column that matches assumption about catch (#2 is baseline, 4 is double mixed stock catch pre collapse)#
# age composition: assume a ESS of 100 if directly observed, 25 otherwise#
#ESS = ifelse(age$GoodData == 1, 100, 25)#
ESS = age$ESS#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))#
X = round(apply(X, 2, function(x) x * ESS))#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X#
#------------------------------------------------------------------------------##
#  Bayes model#
#------------------------------------------------------------------------------##
modelFilename = "dep_mod.txt"#
  cat("#
model {#
  # priors for SR portion#
  lnalpha ~ dunif(0,3) #
  beta ~ dunif(0,10)#
  #beta ~ dnorm(bpmu,bptau)#
  tau.R ~ dgamma(0.01,0.01)  # white noise process error      #
  phi ~ dunif(-0.99, 0.99)   # autocorrelation coefficient                                              #
  log.resid.0 ~ dnorm(0, tau.red)  # starting residual for AR1 process#
  # Ricker SR with AR1 process on log recruitment residuals for years with brood year spawners#
  for (y in (A+a.min):nRyrs) {#
    log.R[y] ~ dnorm(log.R.mean.2[y], tau.R)  # true state R is lognormally distributed around the prediction given by SR with AR1#
    R[y] <- exp(log.R[y])#
    log.R.mean.1[y] <- lnalpha + log(S[y-a.max]) - beta * S[y-a.max]#
    log.resid.a[y] <- log.R[y] - log.R.mean.1[y]#
  }             #
  log.R.mean.2[A+a.min] <- log.R.mean.1[A+a.min] + phi * log.resid.0#
  for (y in (A+a.min+1):nRyrs) {#
    log.R.mean.2[y] <- log.R.mean.1[y] + phi * log.resid.a[y-1]#
  }#
  #derived quantities#
  tau.red <- tau.R * (1 - phi * phi)#
  sigma.red <- 1 / sqrt(tau.red)#
  sigma.R <- 1 / sqrt(tau.R)#
  alpha <- exp(lnalpha)#
  log.resid <- log.resid.a[(A+a.min):nRyrs]#
  # First `a.max` years of recruits, for which there is no spawner link#
  mean.log.R0 ~ dnorm(0, 1E-4) #
  mean.R0 <- exp(mean.log.R0)#
  tau.R0 ~ dgamma(0.1,0.1)#
  sigma.R0 <- 1/sqrt(tau.R0)#
  for (y in 1:a.max) {#
    log.R[y] ~ dnorm(mean.log.R0, tau.R0)   #
    R[y] <- exp(log.R[y])#
  }#
  # biological reference points: derived quantities#
  lnalpha.c <- lnalpha + (sigma.R * sigma.R)/2/(1-phi * phi)#
  S.max <- 1/beta#
  S.eq <- lnalpha.c * S.max#
  S.msy <- S.eq * (0.5 - 0.07 * lnalpha.c)#
  U.msy <- lnalpha.c * (0.5 - 0.07 * lnalpha.c)#
  # Maturity schedule: here we use a common maturation schedule to draw the brood year specific schedules;#
  prob[1] ~ dbeta(1,1)#
  prob[2] ~ dbeta(1,1)#
  prob[3] ~ dbeta(1,1)#
  pi[1]<- prob[1]#
  pi[2] <- prob[2] * (1 - pi[1])#
  pi[3] <- prob[3] * (1 - pi[1] - pi[2])#
  pi[4] <- 1 - pi[1] - pi[2] - pi[3]#
  D.scale ~ dunif(.045,1)#
  D.sum <- 1 / (D.scale * D.scale)#
  for (a in 1:A) {#
    gamma[a] <- D.sum * pi[a]#
    for (y in 1:(Y+A-1)) {                                                    #
      g[y,a] ~ dgamma(gamma[a],1.0)#
      p[y,a] <- g[y,a]/sum(g[y,])#
    }#
  }#
  # Calculate the numbers at age matrix as brood year recruits at age (proportion that matured that year)#
  for (t in 1:Y) {#
    for(a in 1:A){#
      N.ta[t,a] <- R[t+A-a] * p[t+A-a,a]#
    }#
  }#
  ## OBSERVATION SUBMODEL ###
  # multinomial scale sampling#
  for (t in 1:Y) {#
    for (a in 1:A) {#
      q[t,a] <- N.ta[t,a]/N[t]#
    }#
    x[t,1:A] ~ dmulti(q[t,1:A], n[t])#
  }#
  for (t in 1:Y) {#
    # get observation tau's from assumed CV's#
    log.sigma.C[t] <- sqrt(log((C.cv[t]^2) + 1))#
    log.tau.C[t] <- 1/log.sigma.C[t]^2#
    log.sigma.S[t] <- sqrt(log((S.cv[t]^2) + 1))#
    log.tau.S[t] <- 1/log.sigma.S[t]^2#
    # catch model#
    U[t] ~ dunif(0.01, 0.99)#
    N[t] <- sum(N.ta[t,1:A])#
    S[t] <- N[t] * (1 - U[t])#
    C[t] <- N[t] * U[t]#
    log.C[t] <- log(C[t])#
    C.obs[t] ~ dlnorm(log.C[t], log.tau.C[t])#
    # escapement model#
    log.S[t] <- log(S[t])#
    S.obs[t] ~ dlnorm(log.S[t], log.tau.S[t])#
  }#
}#
", fill=TRUE, file=modelFilename)#
#file.show(modelFilename)#
#------------------------------------------------------------------------------##
#  Jags inputs#
#------------------------------------------------------------------------------##
	jags.data = list('Y','a.min','a.max','A','nRyrs','S.cv','S.obs','C.cv','C.obs',#
	               'x','n','bpmu','bptau')#
	jags.parms = c("R", "N", "S", "U", "alpha", "beta", "lnalpha", "phi", "C", "log.resid",#
	               "log.resid.0","sigma.R", "lnalpha.c", "mean.log.R0", "pi", "q", #
	               "mean.R0", "sigma.R0","S.msy", "S.max", "S.eq", "U.msy", "gamma", #
	               "D.sum", "p","log.S")#
#------------------------------------------------------------------------------##
#   Fit Model#
#------------------------------------------------------------------------------##
ptm = proc.time()#
	jagsfit.p <- jags.parallel(data=jags.data,  parameters.to.save=jags.parms,n.thin=15,#
	              n.iter=300000, model.file=modelFilename,n.burnin = 50000,n.chains=6)#
endtime = proc.time()-ptm#
endtime[3]/60#
post = as.mcmc(jagsfit.p)#
mypost = as.matrix(post, chain=F)#
#
saveRDS(post,"outputs/Atnarko_posteriors.2timesmixedstock.May142019.mcmc")
S.cv
S.cv = ifelse(esc[,3] == 1, 1, 0.5)
S.cv
C.cv
S.cv = ifelse(esc[,3] == 1, 0.5, 1)
S.cv
x
#ESS = ifelse(age$GoodData == 1, 100, 25)#
ESS = age$ESS#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))#
#X = round(apply(X, 2, function(x) x * ESS))#
X = round(apply(X, 2, function(x) x * ESS))/2#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X
x
ESS = age$ESS/2#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))#
X = round(apply(X, 2, function(x) x * ESS))#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X
x
age = read.delim("data/AgeCompTab.txt")#
esc = read.csv("data/EscTab.csv")#
harv = read.csv("data/HarTab.csv")#
#------------------------------------------------------------------------------##
#   Set beta prior for stock (uniform (uninformative) prior can be commented#
#	out in model description (line 58)) #
#------------------------------------------------------------------------------##
SMAX <- mean(esc[,2]) # mean escapement over time series#
#SMAX <- 21300 # lake habitat (photosynthetic rate) based estimate of lake capacity#
#
bpmu = 1/SMAX # turn SMAX into beta prior#
bptau = 1/(0.3^2)  # set CV on prior#
#------------------------------------------------------------------------------##
#   Format data#
#------------------------------------------------------------------------------##
Y = nrow(age)             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
years = age[,"year"]#
# escapement: assume a 20% observation CV if directly observed, 40% otherwise#
#S.cv = ifelse(esc[,3] == 1, 0.5, 1)#
S.cv = ifelse(esc[,3] == 1, 1, 2)#
S.obs = esc[,2]#
# harvest: assume a 15% observation CV for years when catch was high and dominated by commercial fishery, 30% in years since#
#C.cv = ifelse(harv[,3] == 1, 0.15, 0.30)#
C.cv = ifelse(harv[,3] == 1, 0.3, 0.6)#
C.obs = harv[,2] # choose column that matches assumption about catch (#2 is baseline, 4 is double mixed stock catch pre collapse)#
# age composition: assume a ESS of 100 if directly observed, 25 otherwise#
#ESS = ifelse(age$GoodData == 1, 100, 25)#
#ESS = age$ESS#
ESS = age$ESS/2#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))#
X = round(apply(X, 2, function(x) x * ESS))#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X#
#------------------------------------------------------------------------------##
#  Bayes model#
#------------------------------------------------------------------------------##
modelFilename = "dep_mod.txt"#
  cat("#
model {#
  # priors for SR portion#
  lnalpha ~ dunif(0,3) #
  beta ~ dunif(0,10)#
  #beta ~ dnorm(bpmu,bptau)#
  tau.R ~ dgamma(0.01,0.01)  # white noise process error      #
  phi ~ dunif(-0.99, 0.99)   # autocorrelation coefficient                                              #
  log.resid.0 ~ dnorm(0, tau.red)  # starting residual for AR1 process#
  # Ricker SR with AR1 process on log recruitment residuals for years with brood year spawners#
  for (y in (A+a.min):nRyrs) {#
    log.R[y] ~ dnorm(log.R.mean.2[y], tau.R)  # true state R is lognormally distributed around the prediction given by SR with AR1#
    R[y] <- exp(log.R[y])#
    log.R.mean.1[y] <- lnalpha + log(S[y-a.max]) - beta * S[y-a.max]#
    log.resid.a[y] <- log.R[y] - log.R.mean.1[y]#
  }             #
  log.R.mean.2[A+a.min] <- log.R.mean.1[A+a.min] + phi * log.resid.0#
  for (y in (A+a.min+1):nRyrs) {#
    log.R.mean.2[y] <- log.R.mean.1[y] + phi * log.resid.a[y-1]#
  }#
  #derived quantities#
  tau.red <- tau.R * (1 - phi * phi)#
  sigma.red <- 1 / sqrt(tau.red)#
  sigma.R <- 1 / sqrt(tau.R)#
  alpha <- exp(lnalpha)#
  log.resid <- log.resid.a[(A+a.min):nRyrs]#
  # First `a.max` years of recruits, for which there is no spawner link#
  mean.log.R0 ~ dnorm(0, 1E-4) #
  mean.R0 <- exp(mean.log.R0)#
  tau.R0 ~ dgamma(0.1,0.1)#
  sigma.R0 <- 1/sqrt(tau.R0)#
  for (y in 1:a.max) {#
    log.R[y] ~ dnorm(mean.log.R0, tau.R0)   #
    R[y] <- exp(log.R[y])#
  }#
  # biological reference points: derived quantities#
  lnalpha.c <- lnalpha + (sigma.R * sigma.R)/2/(1-phi * phi)#
  S.max <- 1/beta#
  S.eq <- lnalpha.c * S.max#
  S.msy <- S.eq * (0.5 - 0.07 * lnalpha.c)#
  U.msy <- lnalpha.c * (0.5 - 0.07 * lnalpha.c)#
  # Maturity schedule: here we use a common maturation schedule to draw the brood year specific schedules;#
  prob[1] ~ dbeta(1,1)#
  prob[2] ~ dbeta(1,1)#
  prob[3] ~ dbeta(1,1)#
  pi[1]<- prob[1]#
  pi[2] <- prob[2] * (1 - pi[1])#
  pi[3] <- prob[3] * (1 - pi[1] - pi[2])#
  pi[4] <- 1 - pi[1] - pi[2] - pi[3]#
  D.scale ~ dunif(.045,1)#
  D.sum <- 1 / (D.scale * D.scale)#
  for (a in 1:A) {#
    gamma[a] <- D.sum * pi[a]#
    for (y in 1:(Y+A-1)) {                                                    #
      g[y,a] ~ dgamma(gamma[a],1.0)#
      p[y,a] <- g[y,a]/sum(g[y,])#
    }#
  }#
  # Calculate the numbers at age matrix as brood year recruits at age (proportion that matured that year)#
  for (t in 1:Y) {#
    for(a in 1:A){#
      N.ta[t,a] <- R[t+A-a] * p[t+A-a,a]#
    }#
  }#
  ## OBSERVATION SUBMODEL ###
  # multinomial scale sampling#
  for (t in 1:Y) {#
    for (a in 1:A) {#
      q[t,a] <- N.ta[t,a]/N[t]#
    }#
    x[t,1:A] ~ dmulti(q[t,1:A], n[t])#
  }#
  for (t in 1:Y) {#
    # get observation tau's from assumed CV's#
    log.sigma.C[t] <- sqrt(log((C.cv[t]^2) + 1))#
    log.tau.C[t] <- 1/log.sigma.C[t]^2#
    log.sigma.S[t] <- sqrt(log((S.cv[t]^2) + 1))#
    log.tau.S[t] <- 1/log.sigma.S[t]^2#
    # catch model#
    U[t] ~ dunif(0.01, 0.99)#
    N[t] <- sum(N.ta[t,1:A])#
    S[t] <- N[t] * (1 - U[t])#
    C[t] <- N[t] * U[t]#
    log.C[t] <- log(C[t])#
    C.obs[t] ~ dlnorm(log.C[t], log.tau.C[t])#
    # escapement model#
    log.S[t] <- log(S[t])#
    S.obs[t] ~ dlnorm(log.S[t], log.tau.S[t])#
  }#
}#
", fill=TRUE, file=modelFilename)#
#file.show(modelFilename)#
#------------------------------------------------------------------------------##
#  Jags inputs#
#------------------------------------------------------------------------------##
	jags.data = list('Y','a.min','a.max','A','nRyrs','S.cv','S.obs','C.cv','C.obs',#
	               'x','n','bpmu','bptau')#
	jags.parms = c("R", "N", "S", "U", "alpha", "beta", "lnalpha", "phi", "C", "log.resid",#
	               "log.resid.0","sigma.R", "lnalpha.c", "mean.log.R0", "pi", "q", #
	               "mean.R0", "sigma.R0","S.msy", "S.max", "S.eq", "U.msy", "gamma", #
	               "D.sum", "p","log.S")#
#------------------------------------------------------------------------------##
#   Fit Model#
#------------------------------------------------------------------------------##
ptm = proc.time()#
	jagsfit.p <- jags.parallel(data=jags.data,  parameters.to.save=jags.parms,n.thin=15,#
	              n.iter=300000, model.file=modelFilename,n.burnin = 50000,n.chains=6)#
endtime = proc.time()-ptm#
endtime[3]/60#
post = as.mcmc(jagsfit.p)#
mypost = as.matrix(post, chain=F)#
#
saveRDS(post,"outputs/Atnarko_posteriors.2timesuncertain.May142019.mcmc")
age = read.delim("data/AgeCompTab.txt")#
esc = read.csv("data/EscTab.csv")#
harv = read.csv("data/HarTab.csv")#
#------------------------------------------------------------------------------##
#   Set beta prior for stock (uniform (uninformative) prior can be commented#
#	out in model description (line 58)) #
#------------------------------------------------------------------------------##
SMAX <- mean(esc[,2]) # mean escapement over time series#
#SMAX <- 21300 # lake habitat (photosynthetic rate) based estimate of lake capacity#
#
bpmu = 1/SMAX # turn SMAX into beta prior#
bptau = 1/(0.3^2)  # set CV on prior#
#------------------------------------------------------------------------------##
#   Format data#
#------------------------------------------------------------------------------##
Y = nrow(age)             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
years = age[,"year"]#
# escapement: assume a 20% observation CV if directly observed, 40% otherwise#
S.cv = ifelse(esc[,3] == 1, 0.5, 1)#
#S.cv = ifelse(esc[,3] == 1, 1, 2)#
S.obs = esc[,2]#
# harvest: assume a 15% observation CV for years when catch was high and dominated by commercial fishery, 30% in years since#
C.cv = ifelse(harv[,3] == 1, 0.15, 0.30)#
#C.cv = ifelse(harv[,3] == 1, 0.3, 0.6)#
C.obs = harv[,4] # choose column that matches assumption about catch (#2 is baseline, 4 is double mixed stock catch pre collapse)#
# age composition#
ESS = age$ESS#
#ESS = age$ESS/2#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))#
X = round(apply(X, 2, function(x) x * ESS))#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X#
#------------------------------------------------------------------------------##
#  Bayes model#
#------------------------------------------------------------------------------##
modelFilename = "dep_mod.txt"#
  cat("#
model {#
  # priors for SR portion#
  lnalpha ~ dunif(0,3) #
  beta ~ dunif(0,10)#
  #beta ~ dnorm(bpmu,bptau)#
  tau.R ~ dgamma(0.01,0.01)  # white noise process error      #
  phi ~ dunif(-0.99, 0.99)   # autocorrelation coefficient                                              #
  log.resid.0 ~ dnorm(0, tau.red)  # starting residual for AR1 process#
  # Ricker SR with AR1 process on log recruitment residuals for years with brood year spawners#
  for (y in (A+a.min):nRyrs) {#
    log.R[y] ~ dnorm(log.R.mean.2[y], tau.R)  # true state R is lognormally distributed around the prediction given by SR with AR1#
    R[y] <- exp(log.R[y])#
    log.R.mean.1[y] <- lnalpha + log(S[y-a.max]) - beta * S[y-a.max]#
    log.resid.a[y] <- log.R[y] - log.R.mean.1[y]#
  }             #
  log.R.mean.2[A+a.min] <- log.R.mean.1[A+a.min] + phi * log.resid.0#
  for (y in (A+a.min+1):nRyrs) {#
    log.R.mean.2[y] <- log.R.mean.1[y] + phi * log.resid.a[y-1]#
  }#
  #derived quantities#
  tau.red <- tau.R * (1 - phi * phi)#
  sigma.red <- 1 / sqrt(tau.red)#
  sigma.R <- 1 / sqrt(tau.R)#
  alpha <- exp(lnalpha)#
  log.resid <- log.resid.a[(A+a.min):nRyrs]#
  # First `a.max` years of recruits, for which there is no spawner link#
  mean.log.R0 ~ dnorm(0, 1E-4) #
  mean.R0 <- exp(mean.log.R0)#
  tau.R0 ~ dgamma(0.1,0.1)#
  sigma.R0 <- 1/sqrt(tau.R0)#
  for (y in 1:a.max) {#
    log.R[y] ~ dnorm(mean.log.R0, tau.R0)   #
    R[y] <- exp(log.R[y])#
  }#
  # biological reference points: derived quantities#
  lnalpha.c <- lnalpha + (sigma.R * sigma.R)/2/(1-phi * phi)#
  S.max <- 1/beta#
  S.eq <- lnalpha.c * S.max#
  S.msy <- S.eq * (0.5 - 0.07 * lnalpha.c)#
  U.msy <- lnalpha.c * (0.5 - 0.07 * lnalpha.c)#
  # Maturity schedule: here we use a common maturation schedule to draw the brood year specific schedules;#
  prob[1] ~ dbeta(1,1)#
  prob[2] ~ dbeta(1,1)#
  prob[3] ~ dbeta(1,1)#
  pi[1]<- prob[1]#
  pi[2] <- prob[2] * (1 - pi[1])#
  pi[3] <- prob[3] * (1 - pi[1] - pi[2])#
  pi[4] <- 1 - pi[1] - pi[2] - pi[3]#
  D.scale ~ dunif(.045,1)#
  D.sum <- 1 / (D.scale * D.scale)#
  for (a in 1:A) {#
    gamma[a] <- D.sum * pi[a]#
    for (y in 1:(Y+A-1)) {                                                    #
      g[y,a] ~ dgamma(gamma[a],1.0)#
      p[y,a] <- g[y,a]/sum(g[y,])#
    }#
  }#
  # Calculate the numbers at age matrix as brood year recruits at age (proportion that matured that year)#
  for (t in 1:Y) {#
    for(a in 1:A){#
      N.ta[t,a] <- R[t+A-a] * p[t+A-a,a]#
    }#
  }#
  ## OBSERVATION SUBMODEL ###
  # multinomial scale sampling#
  for (t in 1:Y) {#
    for (a in 1:A) {#
      q[t,a] <- N.ta[t,a]/N[t]#
    }#
    x[t,1:A] ~ dmulti(q[t,1:A], n[t])#
  }#
  for (t in 1:Y) {#
    # get observation tau's from assumed CV's#
    log.sigma.C[t] <- sqrt(log((C.cv[t]^2) + 1))#
    log.tau.C[t] <- 1/log.sigma.C[t]^2#
    log.sigma.S[t] <- sqrt(log((S.cv[t]^2) + 1))#
    log.tau.S[t] <- 1/log.sigma.S[t]^2#
    # catch model#
    U[t] ~ dunif(0.01, 0.99)#
    N[t] <- sum(N.ta[t,1:A])#
    S[t] <- N[t] * (1 - U[t])#
    C[t] <- N[t] * U[t]#
    log.C[t] <- log(C[t])#
    C.obs[t] ~ dlnorm(log.C[t], log.tau.C[t])#
    # escapement model#
    log.S[t] <- log(S[t])#
    S.obs[t] ~ dlnorm(log.S[t], log.tau.S[t])#
  }#
}#
", fill=TRUE, file=modelFilename)#
#file.show(modelFilename)#
#------------------------------------------------------------------------------##
#  Jags inputs#
#------------------------------------------------------------------------------##
	jags.data = list('Y','a.min','a.max','A','nRyrs','S.cv','S.obs','C.cv','C.obs',#
	               'x','n','bpmu','bptau')#
	jags.parms = c("R", "N", "S", "U", "alpha", "beta", "lnalpha", "phi", "C", "log.resid",#
	               "log.resid.0","sigma.R", "lnalpha.c", "mean.log.R0", "pi", "q", #
	               "mean.R0", "sigma.R0","S.msy", "S.max", "S.eq", "U.msy", "gamma", #
	               "D.sum", "p","log.S")#
#------------------------------------------------------------------------------##
#   Fit Model#
#------------------------------------------------------------------------------##
ptm = proc.time()#
	jagsfit.p <- jags.parallel(data=jags.data,  parameters.to.save=jags.parms,n.thin=15,#
	              n.iter=300000, model.file=modelFilename,n.burnin = 50000,n.chains=6)#
endtime = proc.time()-ptm#
endtime[3]/60#
post = as.mcmc(jagsfit.p)#
mypost = as.matrix(post, chain=F)#
#
saveRDS(post,"outputs/Atnarko_posteriors.2timesmixedstock.May142019.mcmc")
age = read.delim("data/AgeCompTab.txt")#
esc = read.csv("data/EscTab.csv")#
harv = read.csv("data/HarTab.csv")#
#------------------------------------------------------------------------------##
#   Set beta prior for stock (uniform (uninformative) prior can be commented#
#	out in model description (line 58)) #
#------------------------------------------------------------------------------##
SMAX <- mean(esc[,2]) # mean escapement over time series#
#SMAX <- 21300 # lake habitat (photosynthetic rate) based estimate of lake capacity#
#
bpmu = 1/SMAX # turn SMAX into beta prior#
bptau = 1/(0.3^2)  # set CV on prior#
#------------------------------------------------------------------------------##
#   Format data#
#------------------------------------------------------------------------------##
Y = nrow(age)             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
years = age[,"year"]#
# escapement: assume a 20% observation CV if directly observed, 40% otherwise#
S.cv = ifelse(esc[,3] == 1, 0.5, 1)#
#S.cv = ifelse(esc[,3] == 1, 1, 2)#
S.obs = esc[,2]#
# harvest: assume a 15% observation CV for years when catch was high and dominated by commercial fishery, 30% in years since#
C.cv = ifelse(harv[,3] == 1, 0.15, 0.30)#
#C.cv = ifelse(harv[,3] == 1, 0.3, 0.6)#
C.obs = harv[,2] # choose column that matches assumption about catch (#2 is baseline, 4 is double mixed stock catch pre collapse)#
# age composition#
ESS = age$ESS#
#ESS = age$ESS/2#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))#
X = round(apply(X, 2, function(x) x * ESS))#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X#
#------------------------------------------------------------------------------##
#  Bayes model#
#------------------------------------------------------------------------------##
modelFilename = "dep_mod.txt"#
  cat("#
model {#
  # priors for SR portion#
  lnalpha ~ dunif(0,3) #
  beta ~ dunif(0,10)#
  #beta ~ dnorm(bpmu,bptau)#
  tau.R ~ dgamma(0.01,0.01)  # white noise process error      #
  phi ~ dunif(-0.99, 0.99)   # autocorrelation coefficient                                              #
  log.resid.0 ~ dnorm(0, tau.red)  # starting residual for AR1 process#
  # Ricker SR with AR1 process on log recruitment residuals for years with brood year spawners#
  for (y in (A+a.min):nRyrs) {#
    log.R[y] ~ dnorm(log.R.mean.2[y], tau.R)  # true state R is lognormally distributed around the prediction given by SR with AR1#
    R[y] <- exp(log.R[y])#
    log.R.mean.1[y] <- lnalpha + log(S[y-a.max]) - beta * S[y-a.max]#
    log.resid.a[y] <- log.R[y] - log.R.mean.1[y]#
  }             #
  log.R.mean.2[A+a.min] <- log.R.mean.1[A+a.min] + phi * log.resid.0#
  for (y in (A+a.min+1):nRyrs) {#
    log.R.mean.2[y] <- log.R.mean.1[y] + phi * log.resid.a[y-1]#
  }#
  #derived quantities#
  tau.red <- tau.R * (1 - phi * phi)#
  sigma.red <- 1 / sqrt(tau.red)#
  sigma.R <- 1 / sqrt(tau.R)#
  alpha <- exp(lnalpha)#
  log.resid <- log.resid.a[(A+a.min):nRyrs]#
  # First `a.max` years of recruits, for which there is no spawner link#
  mean.log.R0 ~ dnorm(0, 1E-4) #
  mean.R0 <- exp(mean.log.R0)#
  tau.R0 ~ dgamma(0.1,0.1)#
  sigma.R0 <- 1/sqrt(tau.R0)#
  for (y in 1:a.max) {#
    log.R[y] ~ dnorm(mean.log.R0, tau.R0)   #
    R[y] <- exp(log.R[y])#
  }#
  # biological reference points: derived quantities#
  lnalpha.c <- lnalpha + (sigma.R * sigma.R)/2/(1-phi * phi)#
  S.max <- 1/beta#
  S.eq <- lnalpha.c * S.max#
  S.msy <- S.eq * (0.5 - 0.07 * lnalpha.c)#
  U.msy <- lnalpha.c * (0.5 - 0.07 * lnalpha.c)#
  # Maturity schedule: here we use a common maturation schedule to draw the brood year specific schedules;#
  prob[1] ~ dbeta(1,1)#
  prob[2] ~ dbeta(1,1)#
  prob[3] ~ dbeta(1,1)#
  pi[1]<- prob[1]#
  pi[2] <- prob[2] * (1 - pi[1])#
  pi[3] <- prob[3] * (1 - pi[1] - pi[2])#
  pi[4] <- 1 - pi[1] - pi[2] - pi[3]#
  D.scale ~ dunif(.045,1)#
  D.sum <- 1 / (D.scale * D.scale)#
  for (a in 1:A) {#
    gamma[a] <- D.sum * pi[a]#
    for (y in 1:(Y+A-1)) {                                                    #
      g[y,a] ~ dgamma(gamma[a],1.0)#
      p[y,a] <- g[y,a]/sum(g[y,])#
    }#
  }#
  # Calculate the numbers at age matrix as brood year recruits at age (proportion that matured that year)#
  for (t in 1:Y) {#
    for(a in 1:A){#
      N.ta[t,a] <- R[t+A-a] * p[t+A-a,a]#
    }#
  }#
  ## OBSERVATION SUBMODEL ###
  # multinomial scale sampling#
  for (t in 1:Y) {#
    for (a in 1:A) {#
      q[t,a] <- N.ta[t,a]/N[t]#
    }#
    x[t,1:A] ~ dmulti(q[t,1:A], n[t])#
  }#
  for (t in 1:Y) {#
    # get observation tau's from assumed CV's#
    log.sigma.C[t] <- sqrt(log((C.cv[t]^2) + 1))#
    log.tau.C[t] <- 1/log.sigma.C[t]^2#
    log.sigma.S[t] <- sqrt(log((S.cv[t]^2) + 1))#
    log.tau.S[t] <- 1/log.sigma.S[t]^2#
    # catch model#
    U[t] ~ dunif(0.01, 0.99)#
    N[t] <- sum(N.ta[t,1:A])#
    S[t] <- N[t] * (1 - U[t])#
    C[t] <- N[t] * U[t]#
    log.C[t] <- log(C[t])#
    C.obs[t] ~ dlnorm(log.C[t], log.tau.C[t])#
    # escapement model#
    log.S[t] <- log(S[t])#
    S.obs[t] ~ dlnorm(log.S[t], log.tau.S[t])#
  }#
}#
", fill=TRUE, file=modelFilename)#
#file.show(modelFilename)#
#------------------------------------------------------------------------------##
#  Jags inputs#
#------------------------------------------------------------------------------##
	jags.data = list('Y','a.min','a.max','A','nRyrs','S.cv','S.obs','C.cv','C.obs',#
	               'x','n','bpmu','bptau')#
	jags.parms = c("R", "N", "S", "U", "alpha", "beta", "lnalpha", "phi", "C", "log.resid",#
	               "log.resid.0","sigma.R", "lnalpha.c", "mean.log.R0", "pi", "q", #
	               "mean.R0", "sigma.R0","S.msy", "S.max", "S.eq", "U.msy", "gamma", #
	               "D.sum", "p","log.S")#
#------------------------------------------------------------------------------##
#   Fit Model#
#------------------------------------------------------------------------------##
ptm = proc.time()#
	jagsfit.p <- jags.parallel(data=jags.data,  parameters.to.save=jags.parms,n.thin=15,#
	              n.iter=300000, model.file=modelFilename,n.burnin = 50000,n.chains=6)#
endtime = proc.time()-ptm#
endtime[3]/60#
post = as.mcmc(jagsfit.p)#
mypost = as.matrix(post, chain=F)#
#
saveRDS(post,"outputs/Atnarko_posteriors.baseline.May142019.mcmc")
gelman.diag(post, multivariate = F)
#------------------------------------------------------------------------------##
# Run closed loop simulations across a range of harves rates#
#------------------------------------------------------------------------------##
#
#load posterior samples#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesuncertain.May142019.mcmc")#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesmixedstock.May142019.mcmc")#
#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
# set number of simulations and create array to store results #
num.sims = 1000#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}#
saveRDS(temporal.outcomes,"outputs/forward_sims.temp_out.baseline.May142019")  #
saveRDS(static.outcomes,"outputs/forward_sims.static_out.baseline.May142019")  #
(proc.time() - ptm)/60
temporal.outcomes
#------------------------------------------------------------------------------##
# Run closed loop simulations across a range of harves rates#
#------------------------------------------------------------------------------##
#
#load posterior samples#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesuncertain.May142019.mcmc")#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesmixedstock.May142019.mcmc")#
#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
# set number of simulations and create array to store results #
num.sims = 1000#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}#
saveRDS(temporal.outcomes,"outputs/forward_sims.temp_out.2timesuncertain.May142019")  #
saveRDS(static.outcomes,"outputs/forward_sims.static_out.2timesuncertain.May142019")  #
(proc.time() - ptm)/60
#------------------------------------------------------------------------------##
# Run closed loop simulations across a range of harves rates#
#------------------------------------------------------------------------------##
#
#load posterior samples#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesuncertain.May142019.mcmc")#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesmixedstock.May142019.mcmc")#
#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
# set number of simulations and create array to store results #
num.sims = 1000#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}#
saveRDS(temporal.outcomes,"outputs/forward_sims.temp_out.2timesmixedstock.May142019")  #
saveRDS(static.outcomes,"outputs/forward_sims.static_out.2timesmixedstock.May142019")  #
(proc.time() - ptm)/60
# read in posteriors and simulation output#
#
#BASELINE#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
forward_sims <- readRDS("outputs/fforward_sims.temp_out.baseline.May142019")#
forward_res <- readRDS("outputs/forward_sims.static_out.baseline.May142019")#
#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
outcomes.sims <- apply(forward_sims,c(1,2,4),quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9),na.rm=T)#
outcomes.res <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
# some housekeeping#
years <- seq(2005,2017)#
#
nms = dimnames(posteriors)#
#yy <- posteriors[substr(nms, 1, 2) == "S["]#
#spw <- yy[,4:46]#
#
spw <- posteriors[,593:635]#
#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)#
#
# generate plot#
jpeg("figures/figure_5.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=2)#
ablineclip(h=4000,lty=3,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,3),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
# read in posteriors and simulation output#
#
#BASELINE#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
forward_sims <- readRDS("outputs/forward_sims.temp_out.baseline.May142019")#
forward_res <- readRDS("outputs/forward_sims.static_out.baseline.May142019")#
#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
outcomes.sims <- apply(forward_sims,c(1,2,4),quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9),na.rm=T)#
outcomes.res <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
# some housekeeping#
years <- seq(2005,2017)#
#
nms = dimnames(posteriors)#
#yy <- posteriors[substr(nms, 1, 2) == "S["]#
#spw <- yy[,4:46]#
#
spw <- posteriors[,593:635]#
#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)#
#
# generate plot#
jpeg("figures/figure_5.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=2)#
ablineclip(h=4000,lty=3,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,3),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
#2 x catch uncertianty at end of time series#
forward_res <- readRDS("outputs/forward_sims.static_out.baseline.May142019")#
outcomes.res.1 <- apply(forward_res,c(1,2,4),mean,na.rm=T)
#2 x catch uncertianty at end of time series#
forward_res <- readRDS("outputs/forward_sims.static_out.2timesmixedstock.May142019")#
outcomes.res.1 <- apply(forward_res,c(1,2,4),mean,na.rm=T)
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)
dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.5,0,1), #1#
c(0.5,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res.1[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res.1[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,1,]*100,seq(0,0,length.out=length(outcomes.res.1[,1,]*100))),col=trans_col.2,border=NA)#
#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(a)")#
box(col="grey")
dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.5,0,1), #1#
c(0.5,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res.1[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res.1[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,2,]*100,rev(outcomes.res.1[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,1,]*100,seq(0,0,length.out=length(outcomes.res.1[,1,]*100))),col=trans_col.2,border=NA)#
#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(a)")#
box(col="grey")
#2 x catch uncertianty at end of time series#
forward_res <- readRDS("outputs/forward_sims.static_out.2timesuncertain.May142019")#
outcomes.res.2 <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)#
#
# generate plot
dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.5,0,1), #1#
c(0.5,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res.1[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res.1[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,2,]*100,rev(outcomes.res.1[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,1,]*100,seq(0,0,length.out=length(outcomes.res.1[,1,]*100))),col=trans_col.2,border=NA)#
#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.25)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(a)")#
box(col="grey")#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate,outcomes.res.2[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate,outcomes.res.2[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.2[,2,]*100,rev(outcomes.res.2[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.2[,1,]*100,seq(0,0,length.out=length(outcomes.res.2[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")
dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.5,0,1), #1#
c(0.5,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res.1[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res.1[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,2,]*100,rev(outcomes.res.1[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,1,]*100,seq(0,0,length.out=length(outcomes.res.1[,1,]*100))),col=trans_col.2,border=NA)#
#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.25)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(a)")#
box(col="grey")#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate,outcomes.res.2[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate,outcomes.res.2[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.2[,2,]*100,rev(outcomes.res.2[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.2[,1,]*100,seq(0,0,length.out=length(outcomes.res.2[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")
dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.5,0,1), #1#
c(0.5,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res.1[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res.1[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,2,]*100,rev(outcomes.res.1[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,1,]*100,seq(0,0,length.out=length(outcomes.res.1[,1,]*100))),col=trans_col.2,border=NA)#
#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.25)#
mtext("reference point / recovery goal (%)",2,line=2.25)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(a)")#
box(col="grey")#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate,outcomes.res.2[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate,outcomes.res.2[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.2[,2,]*100,rev(outcomes.res.2[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.2[,1,]*100,seq(0,0,length.out=length(outcomes.res.2[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")
dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.5,0,1), #1#
c(0.5,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res.1[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res.1[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,2,]*100,rev(outcomes.res.1[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,1,]*100,seq(0,0,length.out=length(outcomes.res.1[,1,]*100))),col=trans_col.2,border=NA)#
#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.15)#
mtext("reference point / recovery goal (%)",2,line=2.25)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(a)")#
box(col="grey")#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate,outcomes.res.2[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate,outcomes.res.2[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.2[,2,]*100,rev(outcomes.res.2[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.2[,1,]*100,seq(0,0,length.out=length(outcomes.res.2[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")
#------------------------------------------------------------------------------##
# Run closed loop simulations across a range of harves rates#
#------------------------------------------------------------------------------##
#
#load posterior samples#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesuncertain.May142019.mcmc")#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesmixedstock.May142019.mcmc")#
#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
# set number of simulations and create array to store results #
num.sims = 10000#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}#
saveRDS(temporal.outcomes,"outputs/forward_sims.temp_out.2timesmixedstock.May142019")  #
saveRDS(static.outcomes,"outputs/forward_sims.static_out.2timesmixedstock.May142019")  #
(proc.time() - ptm)/60
# set number of simulations and create array to store results
#------------------------------------------------------------------------------##
# Run closed loop simulations across a range of harves rates#
#------------------------------------------------------------------------------##
#
#load posterior samples#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesuncertain.May142019.mcmc")#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesmixedstock.May142019.mcmc")#
#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
# set number of simulations and create array to store results #
num.sims = 10000#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}#
saveRDS(temporal.outcomes,"outputs/forward_sims.temp_out.2timesuncertain.May142019.mcmc")  #
saveRDS(static.outcomes,"outputs/forward_sims.static_out.2timesuncertain.May142019.mcmc")  #
(proc.time() - ptm)/60
#------------------------------------------------------------------------------##
# Run closed loop simulations across a range of harves rates#
#------------------------------------------------------------------------------##
#
#load posterior samples#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesuncertain.May142019.mcmc")#
#sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.2timesmixedstock.May142019.mcmc")#
#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
# set number of simulations and create array to store results #
num.sims = 10000#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}#
saveRDS(temporal.outcomes,"outputs/forward_sims.temp_out.baseline.May142019.mcmc")  #
saveRDS(static.outcomes,"outputs/forward_sims.static_out.baseline.May142019.mcmc")  #
(proc.time() - ptm)/60
# read in posteriors and simulation output#
#
#2 x catch uncertianty at end of time series#
forward_res <- readRDS("outputs/forward_sims.static_out.2timesmixedstock.May142019")#
outcomes.res.1 <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
#2 x catch uncertianty at end of time series#
forward_res <- readRDS("outputs/forward_sims.static_out.2timesuncertain.May142019")#
outcomes.res.2 <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)#
#
# generate plot#
jpeg("figures/figure_S1.jpeg",width=7, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.5,0,1), #1#
c(0.5,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res.1[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res.1[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,2,]*100,rev(outcomes.res.1[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.1[,1,]*100,seq(0,0,length.out=length(outcomes.res.1[,1,]*100))),col=trans_col.2,border=NA)#
#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.15)#
mtext("reference point / recovery goal (%)",2,line=2.25)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(a)")#
box(col="grey")#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate,outcomes.res.2[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate,outcomes.res.2[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.2[,2,]*100,rev(outcomes.res.2[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res.2[,1,]*100,seq(0,0,length.out=length(outcomes.res.2[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
#2 x catch uncertianty at end of time series#
forward_res <- readRDS("outputs/forward_sims.static_out.2timesmixedstock.May142019")#
outcomes.res.1 <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
#2 x catch uncertianty at end of time series#
forward_res <- readRDS("outputs/forward_sims.static_out.2timesuncertain.May142019")#
outcomes.res.2 <- apply(forward_res,c(1,2,4),mean,na.rm=T)
# read in posteriors and simulation output#
#
#BASELINE#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
forward_sims <- readRDS("outputs/forward_sims.temp_out.baseline.May142019")#
forward_res <- readRDS("outputs/forward_sims.static_out.baseline.May142019")#
#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
outcomes.sims <- apply(forward_sims,c(1,2,4),quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9),na.rm=T)#
outcomes.res <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
# some housekeeping#
years <- seq(2005,2017)#
#
nms = dimnames(posteriors)#
#yy <- posteriors[substr(nms, 1, 2) == "S["]#
#spw <- yy[,4:46]#
#
spw <- posteriors[,593:635]#
#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)#
#
# generate plot#
jpeg("figures/figure_5.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=2)#
ablineclip(h=4000,lty=3,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,3),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)#
library(ggplot2)#
library(tidyverse)#
library(viridis)#
library(coda)
# read in posteriors and simulation output#
#
#BASELINE#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
forward_sims <- readRDS("outputs/forward_sims.temp_out.baseline.May142019")#
forward_res <- readRDS("outputs/forward_sims.static_out.baseline.May142019")#
#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
outcomes.sims <- apply(forward_sims,c(1,2,4),quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9),na.rm=T)#
outcomes.res <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
# some housekeeping#
years <- seq(2005,2017)#
#
nms = dimnames(posteriors)#
#yy <- posteriors[substr(nms, 1, 2) == "S["]#
#spw <- yy[,4:46]#
#
spw <- posteriors[,593:635]#
#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)#
#
# generate plot#
jpeg("figures/figure_5.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=2)#
ablineclip(h=4000,lty=3,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,3),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
# load posteriors#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
R = post.summ(sr_model.mcmc, "R[")#
S = post.summ(sr_model.mcmc, "S[")#
resid = post.summ(sr_model.mcmc, "log.resid[")#
#
# re-index spawners, recruits, etc. #
S <- S[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
R <- R[,c(1,12,23,34,42,43,44,45,46,2:11,13:22,24:33,35:41)]#
resid <- resid[,c(1,12,23,34,36:39,2:11,13:22,24:33,35)]
point_col <- viridis(length(R))
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2,col= point_col)
age = read.delim("data/AgeCompTab.txt")
Y = nrow(age)             # number of calendar years observed
Y
Y = 43             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2,col= point_col)
point_col
1:(Y-a.min)
R[3,(a.max + 1):nRyrs]
point_col <- viridis(40)
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2,col= point_col)
point_col
SR_pred_int[2,]
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)
SR_pred_int
SR_pred
# load posteriors#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
R = post.summ(sr_model.mcmc, "R[")#
S = post.summ(sr_model.mcmc, "S[")#
resid = post.summ(sr_model.mcmc, "log.resid[")#
#
# re-index spawners, recruits, etc. #
S <- S[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
R <- R[,c(1,12,23,34,42,43,44,45,46,2:11,13:22,24:33,35:41)]#
resid <- resid[,c(1,12,23,34,36:39,2:11,13:22,24:33,35)]#
#
Y = 43             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
#
#color pallette#
#
point_col <- viridis(40)
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7,col= point_col)
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)
point_col
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)
SR_pred_int
a
b
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)
## Load functions and libraries for analysis#
#
source("functions.R") #
devtools::install_github("jpfrench81/autoimage")#
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)#
library(ggplot2)#
library(tidyverse)#
library(viridis)#
library(coda)#
library(autoimage)
legend.scale(c(0,1),col= point_col)
legend.scale(c(0,1),col= point_col,breaks = c(0, 0.5, 1),axis.args = list(at = c(0, 0.5,  1), las = 2))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 2))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1,axis.lab=c("1990","2000","2017")))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1990","2000","2017")))
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011")))
legend.scale(c(0.5,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011")))
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0,0.1,0.7,1), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")
screen(2)#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011")))
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0,0.3,0.6,1), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011")))
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0,0.3,0.2,1), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011")))
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0,0.3,0.2,1), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011")))
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.6,0.8), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011")))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011")),cex.axis=0.25)
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011")),cex=0.25)
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011"),cex=0.25))
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.6,0.8), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011"),cex=0.25))
dev.off()
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.6,0.8), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011"),cex=0.25))
dev.off()
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.6,0.8), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011"),cex=0.25))#
#
screen(3)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")
## Load functions and libraries for analysis#
#
source("functions.R") #
#devtools::install_github("jpfrench81/autoimage")#
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)#
library(ggplot2)#
library(tidyverse)#
library(viridis)#
library(coda)#
library(autoimage)
# read in posteriors and simulation output#
#
#BASELINE#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
forward_sims <- readRDS("outputs/forward_sims.temp_out.baseline.May142019")#
forward_res <- readRDS("outputs/forward_sims.static_out.baseline.May142019")#
#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
outcomes.sims <- apply(forward_sims,c(1,2,4),quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9),na.rm=T)#
outcomes.res <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
# some housekeeping#
years <- seq(2005,2017)#
#
nms = dimnames(posteriors)#
#yy <- posteriors[substr(nms, 1, 2) == "S["]#
#spw <- yy[,4:46]#
#
spw <- posteriors[,593:635]#
#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)
# load posteriors#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
R = post.summ(sr_model.mcmc, "R[")#
S = post.summ(sr_model.mcmc, "S[")#
resid = post.summ(sr_model.mcmc, "log.resid[")#
#
# re-index spawners, recruits, etc. #
S <- S[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
R <- R[,c(1,12,23,34,42,43,44,45,46,2:11,13:22,24:33,35:41)]#
resid <- resid[,c(1,12,23,34,36:39,2:11,13:22,24:33,35)]#
#
Y = 43             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
#
#color pallette#
#
point_col <- viridis(40)
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.6,0.8), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011"),cex=0.25))
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.8,0.9), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011"),cex.axis=0.25))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 0.5,  1), las = 1, labels =c("1973","1992","2011"),cex.axis=0.65))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, line=0.5))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, line=0))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.05))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=0.05))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=0.5))
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.8,0.9), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=0.5))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=0.5))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=5))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-5))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.5))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.5,padj=2))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.5,padj=20))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.5,padj=1))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.5,padj=0))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.5,padj=-1))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.5,padj=-2))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.5,padj=-3))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.25,padj=-2.5))
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.15,padj=-2.5))
## Load functions and libraries for analysis#
#
source("functions.R") #
#devtools::install_github("jpfrench81/autoimage")#
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)#
library(ggplot2)#
library(tidyverse)#
library(viridis)#
library(coda)#
library(autoimage)
# load posteriors#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.May142019.mcmc")#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
R = post.summ(sr_model.mcmc, "R[")#
S = post.summ(sr_model.mcmc, "S[")#
resid = post.summ(sr_model.mcmc, "log.resid[")#
#
# re-index spawners, recruits, etc. #
S <- S[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
R <- R[,c(1,12,23,34,42,43,44,45,46,2:11,13:22,24:33,35:41)]#
resid <- resid[,c(1,12,23,34,36:39,2:11,13:22,24:33,35)]#
#
Y = 43             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
#
#color pallette#
#
point_col <- viridis(40)#
#
jpeg("figures/figure_4.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.8,0.9), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.15,padj=-2.5))#
#
screen(3)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
jpeg("figures/figure_4.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.8,0.9), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.2,padj=-2.5))#
#
screen(3)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
jpeg("figures/figure_4.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.8,0.9), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.65, tck=-0.25,padj=-2.5))#
#
screen(3)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
jpeg("figures/figure_4.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.8,0.9), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.55, tck=-0.25,padj=-3.5))#
#
screen(3)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
jpeg("figures/figure_4.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.8,0.9), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.55, tck=-0.25,padj=-3.5))#
box(col="grey")#
#
screen(3)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
jpeg("figures/figure_4.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.25,0.35,0.8,0.9), #2#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,,col= point_col,err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol = point_col,cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col= point_col,err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol = point_col,cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
par(mar=c(1,1,0,0))#
#
legend.scale(c(0,1),col= point_col,axis.args = list(at = c(0, 1), las = 1, labels =c("1973","2011"),cex.axis=0.55, tck=-0.25,padj=-3.5))#
#
screen(3)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
## Load functions and libraries for analysis#
#
source("functions.R") #
#devtools::install_github("jpfrench81/autoimage")#
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)#
library(ggplot2)#
library(tidyverse)#
library(viridis)#
library(coda)#
library(autoimage)
age = read.delim("data/AgeCompTab.txt")#
esc = read.csv("data/EscTab.csv")#
harv = read.csv("data/HarTab.csv")#
#------------------------------------------------------------------------------##
#   Set beta prior for stock (uniform (uninformative) prior can be commented#
#	out in model description (line 58)) #
#------------------------------------------------------------------------------##
SMAX <- mean(esc[,2]) # mean escapement over time series#
#SMAX <- 21300 # lake habitat (photosynthetic rate) based estimate of lake capacity#
#
bpmu = 1/SMAX # turn SMAX into beta prior#
bptau = 1/(0.3^2)  # set CV on prior#
#------------------------------------------------------------------------------##
#   Format data#
#------------------------------------------------------------------------------##
Y = nrow(age)             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
years = age[,"year"]#
# escapement: assume a 20% observation CV if directly observed, 40% otherwise#
S.cv = ifelse(esc[,3] == 1, 0.5, 1)#
#S.cv = ifelse(esc[,3] == 1, 1, 2)#
S.obs = esc[,2]#
# harvest: assume a 15% observation CV for years when catch was high and dominated by commercial fishery, 30% in years since#
C.cv = ifelse(harv[,3] == 1, 0.15, 0.30)#
#C.cv = ifelse(harv[,3] == 1, 0.3, 0.6)#
C.obs = harv[,2] # choose column that matches assumption about catch (#2 is baseline, 4 is double mixed stock catch pre collapse)#
# age composition#
ESS = age$ESS#
#ESS = age$ESS/2#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))#
X = round(apply(X, 2, function(x) x * ESS))#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X#
#------------------------------------------------------------------------------##
#  Bayes model#
#------------------------------------------------------------------------------##
modelFilename = "dep_mod.txt"#
  cat("#
model {#
  # priors for SR portion#
  lnalpha ~ dunif(0,3) #
  beta ~ dunif(0,10)#
  #beta ~ dnorm(bpmu,bptau)#
  tau.R ~ dgamma(0.01,0.01)  # white noise process error      #
  phi ~ dunif(-0.99, 0.99)   # autocorrelation coefficient                                              #
  log.resid.0 ~ dnorm(0, tau.red)  # starting residual for AR1 process#
  # Ricker SR with AR1 process on log recruitment residuals for years with brood year spawners#
  for (y in (A+a.min):nRyrs) {#
    log.R[y] ~ dnorm(log.R.mean.2[y], tau.R)  # true state R is lognormally distributed around the prediction given by SR with AR1#
    R[y] <- exp(log.R[y])#
    log.R.mean.1[y] <- lnalpha + log(S[y-a.max]) - beta * S[y-a.max]#
    log.resid.a[y] <- log.R[y] - log.R.mean.1[y]#
  }             #
  log.R.mean.2[A+a.min] <- log.R.mean.1[A+a.min] + phi * log.resid.0#
  for (y in (A+a.min+1):nRyrs) {#
    log.R.mean.2[y] <- log.R.mean.1[y] + phi * log.resid.a[y-1]#
  }#
  #derived quantities#
  tau.red <- tau.R * (1 - phi * phi)#
  sigma.red <- 1 / sqrt(tau.red)#
  sigma.R <- 1 / sqrt(tau.R)#
  alpha <- exp(lnalpha)#
  log.resid <- log.resid.a[(A+a.min):nRyrs]#
  # First `a.max` years of recruits, for which there is no spawner link#
  mean.log.R0 ~ dnorm(0, 1E-4) #
  mean.R0 <- exp(mean.log.R0)#
  tau.R0 ~ dgamma(0.1,0.1)#
  sigma.R0 <- 1/sqrt(tau.R0)#
  for (y in 1:a.max) {#
    log.R[y] ~ dnorm(mean.log.R0, tau.R0)   #
    R[y] <- exp(log.R[y])#
  }#
  # biological reference points: derived quantities#
  lnalpha.c <- lnalpha + (sigma.R * sigma.R)/2/(1-phi * phi)#
  S.max <- 1/beta#
  S.eq <- lnalpha.c * S.max#
  S.msy <- S.eq * (0.5 - 0.07 * lnalpha.c)#
  U.msy <- lnalpha.c * (0.5 - 0.07 * lnalpha.c)#
  # Maturity schedule: here we use a common maturation schedule to draw the brood year specific schedules;#
  prob[1] ~ dbeta(1,1)#
  prob[2] ~ dbeta(1,1)#
  prob[3] ~ dbeta(1,1)#
  pi[1]<- prob[1]#
  pi[2] <- prob[2] * (1 - pi[1])#
  pi[3] <- prob[3] * (1 - pi[1] - pi[2])#
  pi[4] <- 1 - pi[1] - pi[2] - pi[3]#
  D.scale ~ dunif(.045,1)#
  D.sum <- 1 / (D.scale * D.scale)#
  for (a in 1:A) {#
    gamma[a] <- D.sum * pi[a]#
    for (y in 1:(Y+A-1)) {                                                    #
      g[y,a] ~ dgamma(gamma[a],1.0)#
      p[y,a] <- g[y,a]/sum(g[y,])#
    }#
  }#
  # Calculate the numbers at age matrix as brood year recruits at age (proportion that matured that year)#
  for (t in 1:Y) {#
    for(a in 1:A){#
      N.ta[t,a] <- R[t+A-a] * p[t+A-a,a]#
    }#
  }#
  ## OBSERVATION SUBMODEL ###
  # multinomial scale sampling#
  for (t in 1:Y) {#
    for (a in 1:A) {#
      q[t,a] <- N.ta[t,a]/N[t]#
    }#
    x[t,1:A] ~ dmulti(q[t,1:A], n[t])#
  }#
  for (t in 1:Y) {#
    # get observation tau's from assumed CV's#
    log.sigma.C[t] <- sqrt(log((C.cv[t]^2) + 1))#
    log.tau.C[t] <- 1/log.sigma.C[t]^2#
    log.sigma.S[t] <- sqrt(log((S.cv[t]^2) + 1))#
    log.tau.S[t] <- 1/log.sigma.S[t]^2#
    # catch model#
    U[t] ~ dunif(0.01, 0.99)#
    N[t] <- sum(N.ta[t,1:A])#
    S[t] <- N[t] * (1 - U[t])#
    C[t] <- N[t] * U[t]#
    log.C[t] <- log(C[t])#
    C.obs[t] ~ dlnorm(log.C[t], log.tau.C[t])#
    # escapement model#
    log.S[t] <- log(S[t])#
    S.obs[t] ~ dlnorm(log.S[t], log.tau.S[t])#
  }#
}#
", fill=TRUE, file=modelFilename)#
#file.show(modelFilename)#
#------------------------------------------------------------------------------##
#  Jags inputs#
#------------------------------------------------------------------------------##
	jags.data = list('Y','a.min','a.max','A','nRyrs','S.cv','S.obs','C.cv','C.obs',#
	               'x','n','bpmu','bptau')#
	jags.parms = c("R", "N", "S", "U", "alpha", "beta", "lnalpha", "phi", "C", "log.resid",#
	               "log.resid.0","sigma.R", "lnalpha.c", "mean.log.R0", "pi", "q", #
	               "mean.R0", "sigma.R0","S.msy", "S.max", "S.eq", "U.msy", "gamma", #
	               "D.sum", "p","log.S")#
#------------------------------------------------------------------------------##
#   Fit Model#
#------------------------------------------------------------------------------##
ptm = proc.time()#
	jagsfit.p <- jags.parallel(data=jags.data,  parameters.to.save=jags.parms,n.thin=15,#
	              n.iter=300000, model.file=modelFilename,n.burnin = 50000,n.chains=6)#
endtime = proc.time()-ptm#
endtime[3]/60#
post = as.mcmc(jagsfit.p)#
mypost = as.matrix(post, chain=F)
m(list = ls())   #
#
source("load.R")#
#
# generate Figure 2: Exploitation and run time series
source("bayes_sr_model_fit.R")
#------------------------------------------------------------------------------##
# AYK-SSI #1701 Yukon Chinook#
# #
# functions file#
#------------------------------------------------------------------------------##
# Posterior summary function#
post.summ = function(post.samp, var) {#
  post.samp = as.matrix(post.samp)#
  # if parameter is indexed#
  if(substr(var, nchar(var), nchar(var)) == "[") {#
    post = post.samp[,substr(colnames(post.samp), 1, nchar(var)) == var]#
    summ = apply(post, 2, function(x) c(mean = mean(x), sd = sd(x), quantile(x, c(0.5, 0.025, 0.975))))#
    return(summ)#
  }#
  # if parameter is not indexed#
  if(substr(var, nchar(var), nchar(var)) != "[") {#
    post = post.samp[,substr(colnames(post.samp), 1, nchar(var)) == var]#
    summ = c(mean = mean(post), sd = sd(post), quantile(post, c(0.5, 0.025, 0.975)))#
    return(summ)#
  }#
}#
# Function for estimating overfished and extinct#
SC.eq <- function(U,a,b){#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
}#
# not_in function from purrr#
`%not_in%` <- purrr::negate(`%in%`)#
#-------------------------------------------------------------------------------------------------------##
# Portfolio effect function (Nesbitt and Moore. JAE. 2012)#
#-------------------------------------------------------------------------------------------------------##
# data <- dataset#
# first_year <- first year of window over which to calcualte portfolio effects#
# last_year <- last year of window over which to calcualte portfolio effects#
PE_running <- function(data,first_year,last_year){#
  rs_data <- data	#
  rs <- subset(rs_data,year>= first_year & year<last_year)#
  pop_CV <- plyr::ddply(rs,c("stock"),function(x){#
    CV <-sd(x$MLE,na.rm=T)/mean(x$MLE,na.rm=T)#
    abund<-sum(x$MLE,na.rm=T)#
    data.frame(CV,abund)#
  })#
  total.esc <- plyr::ddply(rs,c("year"),function(x){#
    total.esc<-sum(x$MLE,na.rm=T)#
    data.frame(total.esc)#
  })#
  CV_all<-sd(total.esc$total.esc)/mean(total.esc$total.esc)#
  PE.comp <- pop_CV[complete.cases(pop_CV),]#
  PE_all <- sum(PE.comp$abund/sum(PE.comp$abund)* PE.comp$CV) - CV_all#
  return(c(PE_all, CV_all) )#
}#
#-------------------------------------------------------------------------------------------------------##
# Fit JAGS model#
#-------------------------------------------------------------------------------------------------------##
#
jags_fit <- function(stock, age, esc, har){#
  age.pop <- age #
  esc.pop <- esc %>%#
    filter(region == stock) %>%#
    mutate(spawn = case_when(esc_stock == 0 ~ 0.00001,#
                             esc_stock > 0 ~ esc_stock/1000))#
  harv.pop <- harv %>%#
    filter(region == stock) %>%#
    mutate(harvest = harv_stock/1000)#
  SMAX <- mean(esc.pop$spawn) #
  bpmu = 1/SMAX#
  bptau = 1/((1)^2) # CV on prior#
#
  Y = nrow(age.pop)         # number of calendar years observed#
  a.min = 4                 # minimum age class in data set#
  a.max = 7                 # maximum age class in data set#
  A = a.max - a.min + 1     # number of age classes#
  nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
  years = age.pop[,"year"]#
#
  # escapement: assume a 30% observation CV if directly observed, 50% otherwise#
  S.cv = ifelse(esc.pop[,5] == 1, 0.3, 0.5)#
  S.obs = esc.pop[,6]#
  # harvest: assume a 15% observation CV if directly observed, 30% otherwise#
  C.cv = ifelse(harv.pop[,6] == 1, 0.15, 0.30)#
  C.obs = harv.pop[,5]#
  # age composition: assume a ESS of 100 if directly observed, 25 otherwise#
  ESS = ifelse(age.pop$truecount == 1, 100, 25) #
  X <- age.pop %>%#
    select(3:6)#
  X <- as.matrix(X)#
  X = t(apply(X, 1, function(x) x/sum(x)))#
  X = round(apply(X, 2, function(x) x * ESS))#
  colnames(X) = NULL#
  n = rowSums(X)        # n is slightly different than ESS because of rounding errors#
  x=X#
#
  jags.data = list('Y','a.min','a.max','A','nRyrs','S.cv','S.obs','C.cv','C.obs',#
                  'x','n','bpmu','bptau')#
#
  jags.parms = c("R", "N", "S", "U", "alpha", "beta", "lnalpha", "phi", "C", "log.resid",#
                "log.resid.0","sigma.R", "lnalpha.c", "mean.log.R0", "pi", "q", #
                "mean.R0", "sigma.R0","S.msy", "S.max", "S.eq", "U.msy", "gamma", #
                "D.sum", "p","log.S","beta.prior")#
#
  jagsfit <- jags.parallel(data = jags.data,  #
                           parameters.to.save = jags.parms,#
                           n.thin = 5,#
                           n.iter = 300000, #
                           model.file = modelFilename,#
                           n.burnin = 50000,#
                           n.chains = 3)#
  return(jagsfit)#
}
