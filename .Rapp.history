jpeg("figure_3_new.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
#
for(i in 1:100){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	points(spw/1000,(a*spw*exp(-b*spw))/1000,type="l",col=grey(0.8))#
}#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0.2),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col="light grey",border=NA)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity index",2,line=2.5)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
dev.off()
jpeg("figure_3_new.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
#
for(i in 1:100){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	points(spw/1000,(a*spw*exp(-b*spw))/1000,type="l",col=grey(0.8))#
}#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0.2),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col="light grey",border=NA)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity index",2,line=2.5)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
dev.off()
jpeg("figure_3_new.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
#
for(i in 1:100){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	points(spw/1000,(a*spw*exp(-b*spw))/1000,type="l",col=grey(0.8))#
}#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0.2),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col="light grey",border=NA)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity (recruits/spawner)",2,line=2.5)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
jpeg("figures/figure_3_new.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
#
for(i in 1:100){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	points(spw/1000,(a*spw*exp(-b*spw))/1000,type="l",col=grey(0.8))#
}#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0.2),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col="light grey",border=NA)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity (recruits/spawner)",2,line=2.5)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
jpeg("figures/figure_3_new.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
#
for(i in 1:100){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	points(spw/1000,(a*spw*exp(-b*spw))/1000,type="l",col=grey(0.8))#
}#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0.2),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col="light grey",border=NA)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
jpeg("figures/figure_3_new.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
#
for(i in 1:100){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	points(spw/1000,(a*spw*exp(-b*spw))/1000,type="l",col=grey(0.8))#
}#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0.2),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col="light grey",border=NA)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
data/EscTab.csv
post = read.csv("outputs/Atnarko_posteriors.baseline.Apr52019.csv")
gelman.diag(post, multivariate = F)#
R = post.summ(post, "R[")#
S = post.summ(post, "S[")#
N = post.summ(post, "N[")#
U = post.summ(post, "U[")#
resid = post.summ(post, "log.resid[")#
PP = post.summ(post, "pi[")#
alpha = post.summ(post, "alpha")#
beta = post.summ(post, "beta")#
phi = post.summ(post, "phi")#
sigma = post.summ(post, "sigma.R")#
S.msy = post.summ(post, "S.msy")#
S.eq = post.summ(post, "S.eq")#
S.max = post.summ(post, "S.max")#
U.msy = post.summ(post, "U.msy")#
round(rbind(alpha, beta, sigma, phi, S.msy, S.eq, S.max, U.msy), 2)#
mean(mypost[,'beta'])#
S <- S[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
R <- R[,c(1,12,23,34,42,43,44,45,46,2:11,13:22,24:33,35:41)]#
U <- U[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
N <- N[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
resid <- resid[,c(1,12,23,34,36:39,2:11,13:22,24:33,35)]
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)
gelman.diag(post, multivariate = F)#
R = post.summ(post, "R[")#
S = post.summ(post, "S[")#
N = post.summ(post, "N[")#
U = post.summ(post, "U[")#
resid = post.summ(post, "log.resid[")#
PP = post.summ(post, "pi[")#
alpha = post.summ(post, "alpha")#
beta = post.summ(post, "beta")#
phi = post.summ(post, "phi")#
sigma = post.summ(post, "sigma.R")#
S.msy = post.summ(post, "S.msy")#
S.eq = post.summ(post, "S.eq")#
S.max = post.summ(post, "S.max")#
U.msy = post.summ(post, "U.msy")#
round(rbind(alpha, beta, sigma, phi, S.msy, S.eq, S.max, U.msy), 2)#
mean(mypost[,'beta'])#
S <- S[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
R <- R[,c(1,12,23,34,42,43,44,45,46,2:11,13:22,24:33,35:41)]#
U <- U[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
N <- N[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
resid <- resid[,c(1,12,23,34,36:39,2:11,13:22,24:33,35)]
S
as.mcmc(post)
post<-as.mcmc(post)
R = post.summ(post, "R[")#
S = post.summ(post, "S[")#
N = post.summ(post, "N[")#
U = post.summ(post, "U[")#
resid = post.summ(post, "log.resid[")#
PP = post.summ(post, "pi[")#
alpha = post.summ(post, "alpha")#
beta = post.summ(post, "beta")#
phi = post.summ(post, "phi")#
sigma = post.summ(post, "sigma.R")#
S.msy = post.summ(post, "S.msy")#
S.eq = post.summ(post, "S.eq")#
S.max = post.summ(post, "S.max")#
U.msy = post.summ(post, "U.msy")#
round(rbind(alpha, beta, sigma, phi, S.msy, S.eq, S.max, U.msy), 2)#
mean(mypost[,'beta'])#
S <- S[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
R <- R[,c(1,12,23,34,42,43,44,45,46,2:11,13:22,24:33,35:41)]#
U <- U[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
N <- N[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
resid <- resid[,c(1,12,23,34,36:39,2:11,13:22,24:33,35)]
age = read.delim("data/AgeCompTab.txt")#
esc = read.csv("data/EscTab.csv")#
harv = read.csv("data/HarTab.csv")#
#------------------------------------------------------------------------------##
#   Set beta prior for stock (uniform (uninformative) prior can be commented in#
#	or out in model description (line 57)) #
#------------------------------------------------------------------------------##
SMAX <- mean(esc[,2]) # mean escapement over time series#
#SMAX <- 21300 # lake habitat (photosynthetic rate) based estimate of lake capacity#
#
bpmu = 1/SMAX # turn SMAX into beta prior#
bptau = 1/(0.3^2)  # set CV on prior#
#------------------------------------------------------------------------------##
#   Format data#
#------------------------------------------------------------------------------##
Y = nrow(age)             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
years = age[,"year"]#
# escapement: assume a 20% observation CV if directly observed, 40% otherwise#
S.cv = ifelse(esc[,3] == 1, 0.5, 0.5)#
S.obs = esc[,2]#
# harvest: assume a 15% observation CV for years when catch was high and dominated by commercial fishery, 30% in years since#
C.cv = ifelse(harv[,3] == 1, 0.15, 0.30)#
C.obs = harv[,2] # choose column that matches assumption about catch (#2 is baseline, 4 is double mixed stock catch pre collapse)#
# age composition: assume a ESS of 100 if directly observed, 25 otherwise#
#ESS = ifelse(age$GoodData == 1, 100, 25)#
ESS = age$ESS#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))/2#
X = round(apply(X, 2, function(x) x * ESS))#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X#
#------------------------------------------------------------------------------##
#  Bayes model#
#------------------------------------------------------------------------------##
modelFilename = "dep_mod.txt"#
  cat("#
model {#
  # priors for SR portion#
  lnalpha ~ dunif(0,3) #
  beta ~ dunif(0,10)#
  #beta ~ dnorm(bpmu,bptau)#
  #beta.prior ~ dnorm(bpmu,bptau) #for ploting and checking#
  tau.R ~ dgamma(0.01,0.01)  # white noise process error      #
  phi ~ dunif(-0.99, 0.99)   # autocorrelation coefficient                                              #
  log.resid.0 ~ dnorm(0, tau.red)  # starting residual for AR1 process#
  # Ricker SR with AR1 process on log recruitment residuals for years with brood year spawners#
  for (y in (A+a.min):nRyrs) {#
    log.R[y] ~ dnorm(log.R.mean.2[y], tau.R)  # true state R is lognormally distributed around the prediction given by SR with AR1#
    R[y] <- exp(log.R[y])#
    log.R.mean.1[y] <- lnalpha + log(S[y-a.max]) - beta * S[y-a.max]#
    log.resid.a[y] <- log.R[y] - log.R.mean.1[y]#
  }             #
  log.R.mean.2[A+a.min] <- log.R.mean.1[A+a.min] + phi * log.resid.0#
  for (y in (A+a.min+1):nRyrs) {#
    log.R.mean.2[y] <- log.R.mean.1[y] + phi * log.resid.a[y-1]#
  }#
  #derived quantities#
  tau.red <- tau.R * (1 - phi * phi)#
  sigma.red <- 1 / sqrt(tau.red)#
  sigma.R <- 1 / sqrt(tau.R)#
  alpha <- exp(lnalpha)#
  log.resid <- log.resid.a[(A+a.min):nRyrs]#
  # First `a.max` years of recruits, for which there is no spawner link#
  mean.log.R0 ~ dnorm(0, 1E-4) #
  mean.R0 <- exp(mean.log.R0)#
  tau.R0 ~ dgamma(0.1,0.1)#
  sigma.R0 <- 1/sqrt(tau.R0)#
  for (y in 1:a.max) {#
    log.R[y] ~ dnorm(mean.log.R0, tau.R0)   #
    R[y] <- exp(log.R[y])#
  }#
  # biological reference points: derived quantities#
  lnalpha.c <- lnalpha + (sigma.R * sigma.R)/2/(1-phi * phi)#
  S.max <- 1/beta#
  S.eq <- lnalpha.c * S.max#
  S.msy <- S.eq * (0.5 - 0.07 * lnalpha.c)#
  U.msy <- lnalpha.c * (0.5 - 0.07 * lnalpha.c)#
  # Maturity schedule: here we use a common maturation schedule to draw the brood year specific schedules;#
  prob[1] ~ dbeta(1,1)#
  prob[2] ~ dbeta(1,1)#
  prob[3] ~ dbeta(1,1)#
  pi[1]<- prob[1]#
  pi[2] <- prob[2] * (1 - pi[1])#
  pi[3] <- prob[3] * (1 - pi[1] - pi[2])#
  pi[4] <- 1 - pi[1] - pi[2] - pi[3]#
  D.scale ~ dunif(.045,1)#
  D.sum <- 1 / (D.scale * D.scale)#
  for (a in 1:A) {#
    gamma[a] <- D.sum * pi[a]#
    for (y in 1:(Y+A-1)) {                                                    #
      g[y,a] ~ dgamma(gamma[a],1.0)#
      p[y,a] <- g[y,a]/sum(g[y,])#
    }#
  }#
  # Calculate the numbers at age matrix as brood year recruits at age (proportion that matured that year)#
  for (t in 1:Y) {#
    for(a in 1:A){#
      N.ta[t,a] <- R[t+A-a] * p[t+A-a,a]#
    }#
  }#
  ## OBSERVATION SUBMODEL ###
  # multinomial scale sampling#
  for (t in 1:Y) {#
    for (a in 1:A) {#
      q[t,a] <- N.ta[t,a]/N[t]#
    }#
    x[t,1:A] ~ dmulti(q[t,1:A], n[t])#
  }#
  for (t in 1:Y) {#
    # get observation tau's from assumed CV's#
    log.sigma.C[t] <- sqrt(log((C.cv[t]^2) + 1))#
    log.tau.C[t] <- 1/log.sigma.C[t]^2#
    log.sigma.S[t] <- sqrt(log((S.cv[t]^2) + 1))#
    log.tau.S[t] <- 1/log.sigma.S[t]^2#
    # catch model#
    U[t] ~ dunif(0.01, 0.99)#
    N[t] <- sum(N.ta[t,1:A])#
    S[t] <- N[t] * (1 - U[t])#
    C[t] <- N[t] * U[t]#
    log.C[t] <- log(C[t])#
    C.obs[t] ~ dlnorm(log.C[t], log.tau.C[t])#
    # escapement model#
    log.S[t] <- log(S[t])#
    S.obs[t] ~ dlnorm(log.S[t], log.tau.S[t])#
  }#
}#
", fill=TRUE, file=modelFilename)#
#file.show(modelFilename)#
#------------------------------------------------------------------------------##
#  Jags inputs#
#------------------------------------------------------------------------------##
	jags.data = list('Y','a.min','a.max','A','nRyrs','S.cv','S.obs','C.cv','C.obs',#
	               'x','n','bpmu','bptau')#
	jags.parms = c("R", "N", "S", "U", "alpha", "beta", "lnalpha", "phi", "C", "log.resid",#
	               "log.resid.0","sigma.R", "lnalpha.c", "mean.log.R0", "pi", "q", #
	               "mean.R0", "sigma.R0","S.msy", "S.max", "S.eq", "U.msy", "gamma", #
	               "D.sum", "p","log.S")#
#------------------------------------------------------------------------------##
#   Fit Model#
#------------------------------------------------------------------------------##
ptm = proc.time()#
	jagsfit.p <- jags.parallel(data=jags.data,  parameters.to.save=jags.parms,n.thin=15,#
	              n.iter=300000, model.file=modelFilename,n.burnin = 50000,n.chains=6)#
endtime = proc.time()-ptm#
endtime[3]/60#
post = as.mcmc(jagsfit.p)
save.RDS(post,"outputs/Atnarko_posteriors.baseline.Apr72019.mcmc")
saveRDS(post,"outputs/Atnarko_posteriors.baseline.Apr72019.mcmc")
R = post.summ(post, "R[")#
S = post.summ(post, "S[")#
N = post.summ(post, "N[")#
U = post.summ(post, "U[")#
resid = post.summ(post, "log.resid[")#
PP = post.summ(post, "pi[")#
alpha = post.summ(post, "alpha")#
beta = post.summ(post, "beta")#
phi = post.summ(post, "phi")#
sigma = post.summ(post, "sigma.R")#
S.msy = post.summ(post, "S.msy")#
S.eq = post.summ(post, "S.eq")#
S.max = post.summ(post, "S.max")#
U.msy = post.summ(post, "U.msy")#
round(rbind(alpha, beta, sigma, phi, S.msy, S.eq, S.max, U.msy), 2)#
mean(mypost[,'beta'])#
S <- S[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
R <- R[,c(1,12,23,34,42,43,44,45,46,2:11,13:22,24:33,35:41)]#
U <- U[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
N <- N[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
resid <- resid[,c(1,12,23,34,36:39,2:11,13:22,24:33,35)]
S
R
a.max + 1
Y-a.min
nRyrs
#------------------------------------------------------------------------------##
#   Load data  #
#------------------------------------------------------------------------------##
age = read.delim("data/AgeCompTab.txt")#
esc = read.csv("data/EscTab.csv")#
harv = read.csv("data/HarTab.csv")#
#------------------------------------------------------------------------------##
#   Set beta prior for stock (uniform (uninformative) prior can be commented in#
#	or out in model description (line 57)) #
#------------------------------------------------------------------------------##
SMAX <- mean(esc[,2]) # mean escapement over time series#
#SMAX <- 21300 # lake habitat (photosynthetic rate) based estimate of lake capacity#
#
bpmu = 1/SMAX # turn SMAX into beta prior#
bptau = 1/(0.3^2)  # set CV on prior#
#------------------------------------------------------------------------------##
#   Format data#
#------------------------------------------------------------------------------##
Y = nrow(age)             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
years = age[,"year"]
a.max + 1
nRyrs
a.min
Y-a.min
7-47
46-7
# read in posteriors and simulation output#
#
#BASELINE#
posteriors <- read.csv("outputs/Atnarko_posteriors.baseline.Apr52019.csv")#
forward_sims <- readRDS("outputs/forward_sims_baseline.temp_out.Apr52019")#
forward_res <- readRDS("outputs/forward_sims_baseline.static_out.Apr52019")#
#
#2XOBS ERROR#
posteriors <- read.csv("outputs/Atnarko_posteriors.2xobserror.Apr32019.csv")#
forward_sims <- readRDS("outputs/forward_sims_2xobserror.temp_out.Apr22019")#
forward_res <- readRDS("outputs/forward_sims_2xobserror.static_out.Apr22019")#
outcomes.sims <- apply(forward_sims,c(1,2,4),quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9),na.rm=T)#
outcomes.res <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
# some housekeeping#
years <- seq(2005,2017)#
#
nms = names(posteriors)#
yy <- posteriors[substr(nms, 1, 2) == "S."]#
spw <- yy[,4:46]#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)#
#
# generate plot#
jpeg("figures/Figure_4_revised.baseline.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=3)#
ablineclip(h=4000,lty=3,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,3),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=2,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=3,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)
#BASELINE#
posteriors <- read.csv("outputs/Atnarko_posteriors.baseline.Apr52019.csv")#
forward_sims <- readRDS("outputs/forward_sims_baseline.temp_out.Apr52019")#
forward_res <- readRDS("outputs/forward_sims_baseline.static_out.Apr52019")
outcomes.sims <- apply(forward_sims,c(1,2,4),quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9),na.rm=T)#
outcomes.res <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
# some housekeeping#
years <- seq(2005,2017)#
#
nms = names(posteriors)#
yy <- posteriors[substr(nms, 1, 2) == "S."]#
spw <- yy[,4:46]#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)
dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=3)#
ablineclip(h=4000,lty=3,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,3),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=2,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=3,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")
jpeg("figures/Figure_4_revised.baseline.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=3)#
ablineclip(h=4000,lty=3,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,2),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=2,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
jpeg("figures/Figure_4_revised.baseline.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=2)#
ablineclip(h=4000,lty=2,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,2),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=2,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)
age = read.delim("data/AgeCompTab.txt")#
esc = read.csv("data/EscTab.csv")#
harv = read.csv("data/HarTab.csv")#
#------------------------------------------------------------------------------##
#   Set beta prior for stock (uniform (uninformative) prior can be commented in#
#	or out in model description (line 57)) #
#------------------------------------------------------------------------------##
SMAX <- mean(esc[,2]) # mean escapement over time series#
#SMAX <- 21300 # lake habitat (photosynthetic rate) based estimate of lake capacity#
#
bpmu = 1/SMAX # turn SMAX into beta prior#
bptau = 1/(0.3^2)  # set CV on prior#
#------------------------------------------------------------------------------##
#   Format data#
#------------------------------------------------------------------------------##
Y = nrow(age)             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
years = age[,"year"]#
# escapement: assume a 20% observation CV if directly observed, 40% otherwise#
S.cv = ifelse(esc[,3] == 1, 0.5, 0.5)#
S.obs = esc[,2]#
# harvest: assume a 15% observation CV for years when catch was high and dominated by commercial fishery, 30% in years since#
C.cv = ifelse(harv[,3] == 1, 0.15, 0.30)#
C.obs = harv[,2] # choose column that matches assumption about catch (#2 is baseline, 4 is double mixed stock catch pre collapse)#
# age composition: assume a ESS of 100 if directly observed, 25 otherwise#
#ESS = ifelse(age$GoodData == 1, 100, 25)#
ESS = age$ESS#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))/2#
X = round(apply(X, 2, function(x) x * ESS))#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X#
#------------------------------------------------------------------------------##
#  Bayes model#
#------------------------------------------------------------------------------##
modelFilename = "dep_mod.txt"#
  cat("#
model {#
  # priors for SR portion#
  lnalpha ~ dunif(0,3) #
  beta ~ dunif(0,10)#
  #beta ~ dnorm(bpmu,bptau)#
  #beta.prior ~ dnorm(bpmu,bptau) #for ploting and checking#
  tau.R ~ dgamma(0.01,0.01)  # white noise process error      #
  phi ~ dunif(-0.99, 0.99)   # autocorrelation coefficient                                              #
  log.resid.0 ~ dnorm(0, tau.red)  # starting residual for AR1 process#
  # Ricker SR with AR1 process on log recruitment residuals for years with brood year spawners#
  for (y in (A+a.min):nRyrs) {#
    log.R[y] ~ dnorm(log.R.mean.2[y], tau.R)  # true state R is lognormally distributed around the prediction given by SR with AR1#
    R[y] <- exp(log.R[y])#
    log.R.mean.1[y] <- lnalpha + log(S[y-a.max]) - beta * S[y-a.max]#
    log.resid.a[y] <- log.R[y] - log.R.mean.1[y]#
  }             #
  log.R.mean.2[A+a.min] <- log.R.mean.1[A+a.min] + phi * log.resid.0#
  for (y in (A+a.min+1):nRyrs) {#
    log.R.mean.2[y] <- log.R.mean.1[y] + phi * log.resid.a[y-1]#
  }#
  #derived quantities#
  tau.red <- tau.R * (1 - phi * phi)#
  sigma.red <- 1 / sqrt(tau.red)#
  sigma.R <- 1 / sqrt(tau.R)#
  alpha <- exp(lnalpha)#
  log.resid <- log.resid.a[(A+a.min):nRyrs]#
  # First `a.max` years of recruits, for which there is no spawner link#
  mean.log.R0 ~ dnorm(0, 1E-4) #
  mean.R0 <- exp(mean.log.R0)#
  tau.R0 ~ dgamma(0.1,0.1)#
  sigma.R0 <- 1/sqrt(tau.R0)#
  for (y in 1:a.max) {#
    log.R[y] ~ dnorm(mean.log.R0, tau.R0)   #
    R[y] <- exp(log.R[y])#
  }#
  # biological reference points: derived quantities#
  lnalpha.c <- lnalpha + (sigma.R * sigma.R)/2/(1-phi * phi)#
  S.max <- 1/beta#
  S.eq <- lnalpha.c * S.max#
  S.msy <- S.eq * (0.5 - 0.07 * lnalpha.c)#
  U.msy <- lnalpha.c * (0.5 - 0.07 * lnalpha.c)#
  # Maturity schedule: here we use a common maturation schedule to draw the brood year specific schedules;#
  prob[1] ~ dbeta(1,1)#
  prob[2] ~ dbeta(1,1)#
  prob[3] ~ dbeta(1,1)#
  pi[1]<- prob[1]#
  pi[2] <- prob[2] * (1 - pi[1])#
  pi[3] <- prob[3] * (1 - pi[1] - pi[2])#
  pi[4] <- 1 - pi[1] - pi[2] - pi[3]#
  D.scale ~ dunif(.045,1)#
  D.sum <- 1 / (D.scale * D.scale)#
  for (a in 1:A) {#
    gamma[a] <- D.sum * pi[a]#
    for (y in 1:(Y+A-1)) {                                                    #
      g[y,a] ~ dgamma(gamma[a],1.0)#
      p[y,a] <- g[y,a]/sum(g[y,])#
    }#
  }#
  # Calculate the numbers at age matrix as brood year recruits at age (proportion that matured that year)#
  for (t in 1:Y) {#
    for(a in 1:A){#
      N.ta[t,a] <- R[t+A-a] * p[t+A-a,a]#
    }#
  }#
  ## OBSERVATION SUBMODEL ###
  # multinomial scale sampling#
  for (t in 1:Y) {#
    for (a in 1:A) {#
      q[t,a] <- N.ta[t,a]/N[t]#
    }#
    x[t,1:A] ~ dmulti(q[t,1:A], n[t])#
  }#
  for (t in 1:Y) {#
    # get observation tau's from assumed CV's#
    log.sigma.C[t] <- sqrt(log((C.cv[t]^2) + 1))#
    log.tau.C[t] <- 1/log.sigma.C[t]^2#
    log.sigma.S[t] <- sqrt(log((S.cv[t]^2) + 1))#
    log.tau.S[t] <- 1/log.sigma.S[t]^2#
    # catch model#
    U[t] ~ dunif(0.01, 0.99)#
    N[t] <- sum(N.ta[t,1:A])#
    S[t] <- N[t] * (1 - U[t])#
    C[t] <- N[t] * U[t]#
    log.C[t] <- log(C[t])#
    C.obs[t] ~ dlnorm(log.C[t], log.tau.C[t])#
    # escapement model#
    log.S[t] <- log(S[t])#
    S.obs[t] ~ dlnorm(log.S[t], log.tau.S[t])#
  }#
}#
", fill=TRUE, file=modelFilename)#
#file.show(modelFilename)#
#------------------------------------------------------------------------------##
#  Jags inputs#
#------------------------------------------------------------------------------##
	jags.data = list('Y','a.min','a.max','A','nRyrs','S.cv','S.obs','C.cv','C.obs',#
	               'x','n','bpmu','bptau')#
	jags.parms = c("R", "N", "S", "U", "alpha", "beta", "lnalpha", "phi", "C", "log.resid",#
	               "log.resid.0","sigma.R", "lnalpha.c", "mean.log.R0", "pi", "q", #
	               "mean.R0", "sigma.R0","S.msy", "S.max", "S.eq", "U.msy", "gamma", #
	               "D.sum", "p","log.S")#
#------------------------------------------------------------------------------##
#   Fit Model#
#------------------------------------------------------------------------------##
ptm = proc.time()#
	jagsfit.p <- jags.parallel(data=jags.data,  parameters.to.save=jags.parms,n.thin=15,#
	              n.iter=300000, model.file=modelFilename,n.burnin = 50000,n.chains=6)#
endtime = proc.time()-ptm#
endtime[3]/60#
post = as.mcmc(jagsfit.p)#
mypost = as.matrix(post, chain=F)
#potential scale reduction factor#
#
gelman.diag(post, multivariate = F)#
R = post.summ(post, "R[")#
S = post.summ(post, "S[")#
N = post.summ(post, "N[")#
U = post.summ(post, "U[")#
resid = post.summ(post, "log.resid[")#
PP = post.summ(post, "pi[")#
alpha = post.summ(post, "alpha")#
beta = post.summ(post, "beta")#
phi = post.summ(post, "phi")#
sigma = post.summ(post, "sigma.R")#
S.msy = post.summ(post, "S.msy")#
S.eq = post.summ(post, "S.eq")#
S.max = post.summ(post, "S.max")#
U.msy = post.summ(post, "U.msy")#
round(rbind(alpha, beta, sigma, phi, S.msy, S.eq, S.max, U.msy), 2)#
mean(mypost[,'beta'])
quantile(mypost[,'beta'],c(0.025,0.5,0.975))
age = read.delim("data/AgeCompTab.txt")#
esc = read.csv("data/EscTab.csv")#
harv = read.csv("data/HarTab.csv")#
#------------------------------------------------------------------------------##
#   Set beta prior for stock (uniform (uninformative) prior can be commented in#
#	or out in model description (line 57)) #
#------------------------------------------------------------------------------##
SMAX <- mean(esc[,2]) # mean escapement over time series#
#SMAX <- 21300 # lake habitat (photosynthetic rate) based estimate of lake capacity#
#
bpmu = 1/SMAX # turn SMAX into beta prior#
bptau = 1/(0.3^2)  # set CV on prior#
#------------------------------------------------------------------------------##
#   Format data#
#------------------------------------------------------------------------------##
Y = nrow(age)             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
years = age[,"year"]#
# escapement: assume a 20% observation CV if directly observed, 40% otherwise#
S.cv = ifelse(esc[,3] == 1, 0.5, 0.5)#
S.obs = esc[,2]#
# harvest: assume a 15% observation CV for years when catch was high and dominated by commercial fishery, 30% in years since#
C.cv = ifelse(harv[,3] == 1, 0.15, 0.30)#
C.obs = harv[,4] # choose column that matches assumption about catch (#2 is baseline, 4 is double mixed stock catch pre collapse)#
# age composition: assume a ESS of 100 if directly observed, 25 otherwise#
#ESS = ifelse(age$GoodData == 1, 100, 25)#
ESS = age$ESS#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))/2#
X = round(apply(X, 2, function(x) x * ESS))#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X#
#------------------------------------------------------------------------------##
#  Bayes model#
#------------------------------------------------------------------------------##
modelFilename = "dep_mod.txt"#
  cat("#
model {#
  # priors for SR portion#
  lnalpha ~ dunif(0,3) #
  beta ~ dunif(0,10)#
  #beta ~ dnorm(bpmu,bptau)#
  #beta.prior ~ dnorm(bpmu,bptau) #for ploting and checking#
  tau.R ~ dgamma(0.01,0.01)  # white noise process error      #
  phi ~ dunif(-0.99, 0.99)   # autocorrelation coefficient                                              #
  log.resid.0 ~ dnorm(0, tau.red)  # starting residual for AR1 process#
  # Ricker SR with AR1 process on log recruitment residuals for years with brood year spawners#
  for (y in (A+a.min):nRyrs) {#
    log.R[y] ~ dnorm(log.R.mean.2[y], tau.R)  # true state R is lognormally distributed around the prediction given by SR with AR1#
    R[y] <- exp(log.R[y])#
    log.R.mean.1[y] <- lnalpha + log(S[y-a.max]) - beta * S[y-a.max]#
    log.resid.a[y] <- log.R[y] - log.R.mean.1[y]#
  }             #
  log.R.mean.2[A+a.min] <- log.R.mean.1[A+a.min] + phi * log.resid.0#
  for (y in (A+a.min+1):nRyrs) {#
    log.R.mean.2[y] <- log.R.mean.1[y] + phi * log.resid.a[y-1]#
  }#
  #derived quantities#
  tau.red <- tau.R * (1 - phi * phi)#
  sigma.red <- 1 / sqrt(tau.red)#
  sigma.R <- 1 / sqrt(tau.R)#
  alpha <- exp(lnalpha)#
  log.resid <- log.resid.a[(A+a.min):nRyrs]#
  # First `a.max` years of recruits, for which there is no spawner link#
  mean.log.R0 ~ dnorm(0, 1E-4) #
  mean.R0 <- exp(mean.log.R0)#
  tau.R0 ~ dgamma(0.1,0.1)#
  sigma.R0 <- 1/sqrt(tau.R0)#
  for (y in 1:a.max) {#
    log.R[y] ~ dnorm(mean.log.R0, tau.R0)   #
    R[y] <- exp(log.R[y])#
  }#
  # biological reference points: derived quantities#
  lnalpha.c <- lnalpha + (sigma.R * sigma.R)/2/(1-phi * phi)#
  S.max <- 1/beta#
  S.eq <- lnalpha.c * S.max#
  S.msy <- S.eq * (0.5 - 0.07 * lnalpha.c)#
  U.msy <- lnalpha.c * (0.5 - 0.07 * lnalpha.c)#
  # Maturity schedule: here we use a common maturation schedule to draw the brood year specific schedules;#
  prob[1] ~ dbeta(1,1)#
  prob[2] ~ dbeta(1,1)#
  prob[3] ~ dbeta(1,1)#
  pi[1]<- prob[1]#
  pi[2] <- prob[2] * (1 - pi[1])#
  pi[3] <- prob[3] * (1 - pi[1] - pi[2])#
  pi[4] <- 1 - pi[1] - pi[2] - pi[3]#
  D.scale ~ dunif(.045,1)#
  D.sum <- 1 / (D.scale * D.scale)#
  for (a in 1:A) {#
    gamma[a] <- D.sum * pi[a]#
    for (y in 1:(Y+A-1)) {                                                    #
      g[y,a] ~ dgamma(gamma[a],1.0)#
      p[y,a] <- g[y,a]/sum(g[y,])#
    }#
  }#
  # Calculate the numbers at age matrix as brood year recruits at age (proportion that matured that year)#
  for (t in 1:Y) {#
    for(a in 1:A){#
      N.ta[t,a] <- R[t+A-a] * p[t+A-a,a]#
    }#
  }#
  ## OBSERVATION SUBMODEL ###
  # multinomial scale sampling#
  for (t in 1:Y) {#
    for (a in 1:A) {#
      q[t,a] <- N.ta[t,a]/N[t]#
    }#
    x[t,1:A] ~ dmulti(q[t,1:A], n[t])#
  }#
  for (t in 1:Y) {#
    # get observation tau's from assumed CV's#
    log.sigma.C[t] <- sqrt(log((C.cv[t]^2) + 1))#
    log.tau.C[t] <- 1/log.sigma.C[t]^2#
    log.sigma.S[t] <- sqrt(log((S.cv[t]^2) + 1))#
    log.tau.S[t] <- 1/log.sigma.S[t]^2#
    # catch model#
    U[t] ~ dunif(0.01, 0.99)#
    N[t] <- sum(N.ta[t,1:A])#
    S[t] <- N[t] * (1 - U[t])#
    C[t] <- N[t] * U[t]#
    log.C[t] <- log(C[t])#
    C.obs[t] ~ dlnorm(log.C[t], log.tau.C[t])#
    # escapement model#
    log.S[t] <- log(S[t])#
    S.obs[t] ~ dlnorm(log.S[t], log.tau.S[t])#
  }#
}#
", fill=TRUE, file=modelFilename)#
#file.show(modelFilename)#
#------------------------------------------------------------------------------##
#  Jags inputs#
#------------------------------------------------------------------------------##
	jags.data = list('Y','a.min','a.max','A','nRyrs','S.cv','S.obs','C.cv','C.obs',#
	               'x','n','bpmu','bptau')#
	jags.parms = c("R", "N", "S", "U", "alpha", "beta", "lnalpha", "phi", "C", "log.resid",#
	               "log.resid.0","sigma.R", "lnalpha.c", "mean.log.R0", "pi", "q", #
	               "mean.R0", "sigma.R0","S.msy", "S.max", "S.eq", "U.msy", "gamma", #
	               "D.sum", "p","log.S")#
#------------------------------------------------------------------------------##
#   Fit Model#
#------------------------------------------------------------------------------##
ptm = proc.time()#
	jagsfit.p <- jags.parallel(data=jags.data,  parameters.to.save=jags.parms,n.thin=15,#
	              n.iter=300000, model.file=modelFilename,n.burnin = 50000,n.chains=6)#
endtime = proc.time()-ptm#
endtime[3]/60#
post = as.mcmc(jagsfit.p)#
mypost = as.matrix(post, chain=F)
#potential scale reduction factor#
#
gelman.diag(post, multivariate = F)#
R = post.summ(post, "R[")#
S = post.summ(post, "S[")#
N = post.summ(post, "N[")#
U = post.summ(post, "U[")#
resid = post.summ(post, "log.resid[")#
PP = post.summ(post, "pi[")#
alpha = post.summ(post, "alpha")#
beta = post.summ(post, "beta")#
phi = post.summ(post, "phi")#
sigma = post.summ(post, "sigma.R")#
S.msy = post.summ(post, "S.msy")#
S.eq = post.summ(post, "S.eq")#
S.max = post.summ(post, "S.max")#
U.msy = post.summ(post, "U.msy")#
round(rbind(alpha, beta, sigma, phi, S.msy, S.eq, S.max, U.msy), 2)#
quantile(mypost[,'beta'],c(0.025,0.5,0.975))
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)
library(ggplot2)#
library(tidyverse)#
library(viridis)#
#
age_file <-read.delim("data/age_comps.updatedFeb282019.txt",header=T)#
colnames(age_file) <- c("year","3","4","5","6","samples")#
xxx <- age_file[,-6]#
age_comp <- gather(xxx,age,proportion,c("3","4","5","6"))#
age_file$samples#
#
jpeg("figures/age_comps.jpeg",width=5, height=2.5, units="in",res=800)#
#
ggplot() +#
	geom_bar(aes(x=year,y=proportion*100,fill=age), data = age_comp, stat="identity")+#
	scale_fill_manual(values=viridis(4))+#
	annotate("text", x = 1975:2017, y = 105, label = age_file$samples,size=2.35,angle = 45)+#
	coord_cartesian(ylim=c(4,105),xlim=c(1975,2016))+#
	scale_x_continuous("Year",breaks = c(1975,1985,1995,2005,2015))+ #
	scale_y_continuous("Percent of samples",breaks = c(0,20,40,60,80,100))+#
	theme_bw()+#
	theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"),	#
			 legend.key.size=unit(0.5,"cm"),#
			 panel.border = element_rect(color = "grey", fill=NA, size=0.75))#
#
dev.off()
jpeg("figures/age_comps.jpeg",width=6, height=2.5, units="in",res=800)#
#
ggplot() +#
	geom_bar(aes(x=year,y=proportion*100,fill=age), data = age_comp, stat="identity")+#
	scale_fill_manual(values=viridis(4))+#
	annotate("text", x = 1975:2017, y = 105, label = age_file$samples,size=2.35,angle = 45)+#
	coord_cartesian(ylim=c(4,105),xlim=c(1975,2016))+#
	scale_x_continuous("Year",breaks = c(1975,1985,1995,2005,2015))+ #
	scale_y_continuous("Percent of samples",breaks = c(0,20,40,60,80,100))+#
	theme_bw()+#
	theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"),	#
			 legend.key.size=unit(0.5,"cm"),#
			 panel.border = element_rect(color = "grey", fill=NA, size=0.75))#
#
dev.off()
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)
data<-read.table("data/catch_data.txt",header=T)#
dat.matrix<-read.table("data/catch_matrix.txt", header=T)#
mat.short<-read.table("data/catch_matrix.short.txt", header=F)#
mar.short<-as.matrix(mat.short[,2:44])#
tot.inc<-seq(0,120000,15000)#
labs<-c(0,15,30,45,60,75,90,105,120)#
count<-seq(0,40,5)#
years<-seq(1975,2020,5)#
jpeg(filename = "figures/Figure_2.jpeg", width = 7, height = 3.5, units = "in", bg = "white", res = 400)#
#dev.new(width=7, height=3.5)#
par(mar=c(4,4,1,4))#
b<-barplot(mar.short,yaxt="n",xaxt="n",xlab="",ylab="",ylim=c(0,120000))#
axis(side=2, las=2, at=tot.inc, labels=labs,line=-0.25)#
mtext("Sockeye (000s)",side=2,adj=0.5,line=2.5)#
axis(side=1, at=c(0.7,6.7,12.7,18.7,24.7,30.7,36.7,42.7,48.7), labels=c(1975,1980,1985,1990,1995,2000,2005,2010,2015))#
mtext("Year",side=1,line=2.5)#
par(new=TRUE,mar=c(4,4.25,1,4.25))#
plot(harvest_rate~year, xlab="",ylab="",data=data,yaxt="n",xaxt="n", col="red",type="l",lwd=2,bty="l", ylim=c(0,1))#
axis(side=4,at=c(0,0.2,0.4,0.6,0.8,1),labels=c("0","20","40","60","80","100"),las=1)#
mtext("Harvest (%)",side=4,adj=0.5,line=2.5)#
colors<-gray.colors(3, start = 0.3, end = 0.9, gamma = 2.2, alpha = NULL)#
legend(2005,0.9,c("Escapement","Commercial","FSC"),col=colors,pch=15,cex=0.9,bty="n")#
box(col="grey")#
dev.off()
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)
age = read.delim("data/AgeCompTab.txt")#
esc = read.csv("data/EscTab.csv")#
harv = read.csv("data/HarTab.csv")#
#------------------------------------------------------------------------------##
#   Set beta prior for stock (uniform (uninformative) prior can be commented in#
#	or out in model description (line 57)) #
#------------------------------------------------------------------------------##
SMAX <- mean(esc[,2]) # mean escapement over time series#
#SMAX <- 21300 # lake habitat (photosynthetic rate) based estimate of lake capacity#
#
bpmu = 1/SMAX # turn SMAX into beta prior#
bptau = 1/(0.3^2)  # set CV on prior#
#------------------------------------------------------------------------------##
#   Format data#
#------------------------------------------------------------------------------##
Y = nrow(age)             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
years = age[,"year"]#
# escapement: assume a 20% observation CV if directly observed, 40% otherwise#
S.cv = ifelse(esc[,3] == 1, 1, 0.5)#
S.obs = esc[,2]#
# harvest: assume a 15% observation CV for years when catch was high and dominated by commercial fishery, 30% in years since#
C.cv = ifelse(harv[,3] == 1, 0.30, 0.30)#
C.obs = harv[,2] # choose column that matches assumption about catch (#2 is baseline, 4 is double mixed stock catch pre collapse)#
# age composition: assume a ESS of 100 if directly observed, 25 otherwise#
#ESS = ifelse(age$GoodData == 1, 100, 25)#
ESS = age$ESS#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))/2#
X = round(apply(X, 2, function(x) x * ESS))#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X#
#------------------------------------------------------------------------------##
#  Bayes model#
#------------------------------------------------------------------------------##
modelFilename = "dep_mod.txt"#
  cat("#
model {#
  # priors for SR portion#
  lnalpha ~ dunif(0,3) #
  beta ~ dunif(0,10)#
  #beta ~ dnorm(bpmu,bptau)#
  #beta.prior ~ dnorm(bpmu,bptau) #for ploting and checking#
  tau.R ~ dgamma(0.01,0.01)  # white noise process error      #
  phi ~ dunif(-0.99, 0.99)   # autocorrelation coefficient                                              #
  log.resid.0 ~ dnorm(0, tau.red)  # starting residual for AR1 process#
  # Ricker SR with AR1 process on log recruitment residuals for years with brood year spawners#
  for (y in (A+a.min):nRyrs) {#
    log.R[y] ~ dnorm(log.R.mean.2[y], tau.R)  # true state R is lognormally distributed around the prediction given by SR with AR1#
    R[y] <- exp(log.R[y])#
    log.R.mean.1[y] <- lnalpha + log(S[y-a.max]) - beta * S[y-a.max]#
    log.resid.a[y] <- log.R[y] - log.R.mean.1[y]#
  }             #
  log.R.mean.2[A+a.min] <- log.R.mean.1[A+a.min] + phi * log.resid.0#
  for (y in (A+a.min+1):nRyrs) {#
    log.R.mean.2[y] <- log.R.mean.1[y] + phi * log.resid.a[y-1]#
  }#
  #derived quantities#
  tau.red <- tau.R * (1 - phi * phi)#
  sigma.red <- 1 / sqrt(tau.red)#
  sigma.R <- 1 / sqrt(tau.R)#
  alpha <- exp(lnalpha)#
  log.resid <- log.resid.a[(A+a.min):nRyrs]#
  # First `a.max` years of recruits, for which there is no spawner link#
  mean.log.R0 ~ dnorm(0, 1E-4) #
  mean.R0 <- exp(mean.log.R0)#
  tau.R0 ~ dgamma(0.1,0.1)#
  sigma.R0 <- 1/sqrt(tau.R0)#
  for (y in 1:a.max) {#
    log.R[y] ~ dnorm(mean.log.R0, tau.R0)   #
    R[y] <- exp(log.R[y])#
  }#
  # biological reference points: derived quantities#
  lnalpha.c <- lnalpha + (sigma.R * sigma.R)/2/(1-phi * phi)#
  S.max <- 1/beta#
  S.eq <- lnalpha.c * S.max#
  S.msy <- S.eq * (0.5 - 0.07 * lnalpha.c)#
  U.msy <- lnalpha.c * (0.5 - 0.07 * lnalpha.c)#
  # Maturity schedule: here we use a common maturation schedule to draw the brood year specific schedules;#
  prob[1] ~ dbeta(1,1)#
  prob[2] ~ dbeta(1,1)#
  prob[3] ~ dbeta(1,1)#
  pi[1]<- prob[1]#
  pi[2] <- prob[2] * (1 - pi[1])#
  pi[3] <- prob[3] * (1 - pi[1] - pi[2])#
  pi[4] <- 1 - pi[1] - pi[2] - pi[3]#
  D.scale ~ dunif(.045,1)#
  D.sum <- 1 / (D.scale * D.scale)#
  for (a in 1:A) {#
    gamma[a] <- D.sum * pi[a]#
    for (y in 1:(Y+A-1)) {                                                    #
      g[y,a] ~ dgamma(gamma[a],1.0)#
      p[y,a] <- g[y,a]/sum(g[y,])#
    }#
  }#
  # Calculate the numbers at age matrix as brood year recruits at age (proportion that matured that year)#
  for (t in 1:Y) {#
    for(a in 1:A){#
      N.ta[t,a] <- R[t+A-a] * p[t+A-a,a]#
    }#
  }#
  ## OBSERVATION SUBMODEL ###
  # multinomial scale sampling#
  for (t in 1:Y) {#
    for (a in 1:A) {#
      q[t,a] <- N.ta[t,a]/N[t]#
    }#
    x[t,1:A] ~ dmulti(q[t,1:A], n[t])#
  }#
  for (t in 1:Y) {#
    # get observation tau's from assumed CV's#
    log.sigma.C[t] <- sqrt(log((C.cv[t]^2) + 1))#
    log.tau.C[t] <- 1/log.sigma.C[t]^2#
    log.sigma.S[t] <- sqrt(log((S.cv[t]^2) + 1))#
    log.tau.S[t] <- 1/log.sigma.S[t]^2#
    # catch model#
    U[t] ~ dunif(0.01, 0.99)#
    N[t] <- sum(N.ta[t,1:A])#
    S[t] <- N[t] * (1 - U[t])#
    C[t] <- N[t] * U[t]#
    log.C[t] <- log(C[t])#
    C.obs[t] ~ dlnorm(log.C[t], log.tau.C[t])#
    # escapement model#
    log.S[t] <- log(S[t])#
    S.obs[t] ~ dlnorm(log.S[t], log.tau.S[t])#
  }#
}#
", fill=TRUE, file=modelFilename)#
#file.show(modelFilename)#
#------------------------------------------------------------------------------##
#  Jags inputs#
#------------------------------------------------------------------------------##
	jags.data = list('Y','a.min','a.max','A','nRyrs','S.cv','S.obs','C.cv','C.obs',#
	               'x','n','bpmu','bptau')#
	jags.parms = c("R", "N", "S", "U", "alpha", "beta", "lnalpha", "phi", "C", "log.resid",#
	               "log.resid.0","sigma.R", "lnalpha.c", "mean.log.R0", "pi", "q", #
	               "mean.R0", "sigma.R0","S.msy", "S.max", "S.eq", "U.msy", "gamma", #
	               "D.sum", "p","log.S")#
#------------------------------------------------------------------------------##
#   Fit Model#
#------------------------------------------------------------------------------##
ptm = proc.time()#
	jagsfit.p <- jags.parallel(data=jags.data,  parameters.to.save=jags.parms,n.thin=15,#
	              n.iter=300000, model.file=modelFilename,n.burnin = 50000,n.chains=6)#
endtime = proc.time()-ptm#
endtime[3]/60#
post = as.mcmc(jagsfit.p)#
mypost = as.matrix(post, chain=F)
write.csv(mypost,"outputs/Atnarko_posteriors.2Xuncertain.May22019.csv")#
saveRDS(post,"outputs/Atnarko_posteriors.2Xuncertain.May22019.mcmc")
#potential scale reduction factor#
#
gelman.diag(post, multivariate = F)#
R = post.summ(post, "R[")#
S = post.summ(post, "S[")#
N = post.summ(post, "N[")#
U = post.summ(post, "U[")#
resid = post.summ(post, "log.resid[")#
PP = post.summ(post, "pi[")#
alpha = post.summ(post, "alpha")#
beta = post.summ(post, "beta")#
phi = post.summ(post, "phi")#
sigma = post.summ(post, "sigma.R")#
S.msy = post.summ(post, "S.msy")#
S.eq = post.summ(post, "S.eq")#
S.max = post.summ(post, "S.max")#
U.msy = post.summ(post, "U.msy")#
round(rbind(alpha, beta, sigma, phi, S.msy, S.eq, S.max, U.msy), 2)#
quantile(mypost[,'beta'],c(0.025,0.5,0.975))
age = read.delim("data/AgeCompTab.txt")#
esc = read.csv("data/EscTab.csv")#
harv = read.csv("data/HarTab.csv")#
#------------------------------------------------------------------------------##
#   Set beta prior for stock (uniform (uninformative) prior can be commented in#
#	or out in model description (line 57)) #
#------------------------------------------------------------------------------##
SMAX <- mean(esc[,2]) # mean escapement over time series#
#SMAX <- 21300 # lake habitat (photosynthetic rate) based estimate of lake capacity#
#
bpmu = 1/SMAX # turn SMAX into beta prior#
bptau = 1/(0.3^2)  # set CV on prior#
#------------------------------------------------------------------------------##
#   Format data#
#------------------------------------------------------------------------------##
Y = nrow(age)             # number of calendar years observed#
a.min = 3                 # minimum age class in data set#
a.max = 6                 # maximum age class in data set#
A = a.max - a.min + 1     # number of age classes#
nRyrs = Y + A - 1         # number of recruitment years (see model code for details)#
years = age[,"year"]#
# escapement: assume a 20% observation CV if directly observed, 40% otherwise#
S.cv = ifelse(esc[,3] == 0.5, 1, 0.5)#
S.obs = esc[,2]#
# harvest: assume a 15% observation CV for years when catch was high and dominated by commercial fishery, 30% in years since#
C.cv = ifelse(harv[,3] == 1, 0.15, 0.30)#
C.obs = harv[,2] # choose column that matches assumption about catch (#2 is baseline, 4 is double mixed stock catch pre collapse)#
# age composition: assume a ESS of 100 if directly observed, 25 otherwise#
#ESS = ifelse(age$GoodData == 1, 100, 25)#
ESS = age$ESS#
X = age[,substr(names(age), 1, 1) == "X"]#
X = t(apply(X, 1, function(x) x/sum(x)))#
X = round(apply(X, 2, function(x) x * ESS))#
colnames(X) = NULL#
n = rowSums(X)  # n is slightly different than ESS because of rounding errors#
x=X#
#------------------------------------------------------------------------------##
#  Bayes model#
#------------------------------------------------------------------------------##
modelFilename = "dep_mod.txt"#
  cat("#
model {#
  # priors for SR portion#
  lnalpha ~ dunif(0,3) #
  beta ~ dunif(0,10)#
  #beta ~ dnorm(bpmu,bptau)#
  #beta.prior ~ dnorm(bpmu,bptau) #for ploting and checking#
  tau.R ~ dgamma(0.01,0.01)  # white noise process error      #
  phi ~ dunif(-0.99, 0.99)   # autocorrelation coefficient                                              #
  log.resid.0 ~ dnorm(0, tau.red)  # starting residual for AR1 process#
  # Ricker SR with AR1 process on log recruitment residuals for years with brood year spawners#
  for (y in (A+a.min):nRyrs) {#
    log.R[y] ~ dnorm(log.R.mean.2[y], tau.R)  # true state R is lognormally distributed around the prediction given by SR with AR1#
    R[y] <- exp(log.R[y])#
    log.R.mean.1[y] <- lnalpha + log(S[y-a.max]) - beta * S[y-a.max]#
    log.resid.a[y] <- log.R[y] - log.R.mean.1[y]#
  }             #
  log.R.mean.2[A+a.min] <- log.R.mean.1[A+a.min] + phi * log.resid.0#
  for (y in (A+a.min+1):nRyrs) {#
    log.R.mean.2[y] <- log.R.mean.1[y] + phi * log.resid.a[y-1]#
  }#
  #derived quantities#
  tau.red <- tau.R * (1 - phi * phi)#
  sigma.red <- 1 / sqrt(tau.red)#
  sigma.R <- 1 / sqrt(tau.R)#
  alpha <- exp(lnalpha)#
  log.resid <- log.resid.a[(A+a.min):nRyrs]#
  # First `a.max` years of recruits, for which there is no spawner link#
  mean.log.R0 ~ dnorm(0, 1E-4) #
  mean.R0 <- exp(mean.log.R0)#
  tau.R0 ~ dgamma(0.1,0.1)#
  sigma.R0 <- 1/sqrt(tau.R0)#
  for (y in 1:a.max) {#
    log.R[y] ~ dnorm(mean.log.R0, tau.R0)   #
    R[y] <- exp(log.R[y])#
  }#
  # biological reference points: derived quantities#
  lnalpha.c <- lnalpha + (sigma.R * sigma.R)/2/(1-phi * phi)#
  S.max <- 1/beta#
  S.eq <- lnalpha.c * S.max#
  S.msy <- S.eq * (0.5 - 0.07 * lnalpha.c)#
  U.msy <- lnalpha.c * (0.5 - 0.07 * lnalpha.c)#
  # Maturity schedule: here we use a common maturation schedule to draw the brood year specific schedules;#
  prob[1] ~ dbeta(1,1)#
  prob[2] ~ dbeta(1,1)#
  prob[3] ~ dbeta(1,1)#
  pi[1]<- prob[1]#
  pi[2] <- prob[2] * (1 - pi[1])#
  pi[3] <- prob[3] * (1 - pi[1] - pi[2])#
  pi[4] <- 1 - pi[1] - pi[2] - pi[3]#
  D.scale ~ dunif(.045,1)#
  D.sum <- 1 / (D.scale * D.scale)#
  for (a in 1:A) {#
    gamma[a] <- D.sum * pi[a]#
    for (y in 1:(Y+A-1)) {                                                    #
      g[y,a] ~ dgamma(gamma[a],1.0)#
      p[y,a] <- g[y,a]/sum(g[y,])#
    }#
  }#
  # Calculate the numbers at age matrix as brood year recruits at age (proportion that matured that year)#
  for (t in 1:Y) {#
    for(a in 1:A){#
      N.ta[t,a] <- R[t+A-a] * p[t+A-a,a]#
    }#
  }#
  ## OBSERVATION SUBMODEL ###
  # multinomial scale sampling#
  for (t in 1:Y) {#
    for (a in 1:A) {#
      q[t,a] <- N.ta[t,a]/N[t]#
    }#
    x[t,1:A] ~ dmulti(q[t,1:A], n[t])#
  }#
  for (t in 1:Y) {#
    # get observation tau's from assumed CV's#
    log.sigma.C[t] <- sqrt(log((C.cv[t]^2) + 1))#
    log.tau.C[t] <- 1/log.sigma.C[t]^2#
    log.sigma.S[t] <- sqrt(log((S.cv[t]^2) + 1))#
    log.tau.S[t] <- 1/log.sigma.S[t]^2#
    # catch model#
    U[t] ~ dunif(0.01, 0.99)#
    N[t] <- sum(N.ta[t,1:A])#
    S[t] <- N[t] * (1 - U[t])#
    C[t] <- N[t] * U[t]#
    log.C[t] <- log(C[t])#
    C.obs[t] ~ dlnorm(log.C[t], log.tau.C[t])#
    # escapement model#
    log.S[t] <- log(S[t])#
    S.obs[t] ~ dlnorm(log.S[t], log.tau.S[t])#
  }#
}#
", fill=TRUE, file=modelFilename)#
#file.show(modelFilename)#
#------------------------------------------------------------------------------##
#  Jags inputs#
#------------------------------------------------------------------------------##
	jags.data = list('Y','a.min','a.max','A','nRyrs','S.cv','S.obs','C.cv','C.obs',#
	               'x','n','bpmu','bptau')#
	jags.parms = c("R", "N", "S", "U", "alpha", "beta", "lnalpha", "phi", "C", "log.resid",#
	               "log.resid.0","sigma.R", "lnalpha.c", "mean.log.R0", "pi", "q", #
	               "mean.R0", "sigma.R0","S.msy", "S.max", "S.eq", "U.msy", "gamma", #
	               "D.sum", "p","log.S")#
#------------------------------------------------------------------------------##
#   Fit Model#
#------------------------------------------------------------------------------##
ptm = proc.time()#
	jagsfit.p <- jags.parallel(data=jags.data,  parameters.to.save=jags.parms,n.thin=15,#
	              n.iter=300000, model.file=modelFilename,n.burnin = 50000,n.chains=6)#
endtime = proc.time()-ptm#
endtime[3]/60#
post = as.mcmc(jagsfit.p)#
mypost = as.matrix(post, chain=F)
#------------------------------------------------------------------------------##
# Model diagnostics and parameter summary#
#------------------------------------------------------------------------------##
#
#potential scale reduction factor#
#
gelman.diag(post, multivariate = F)#
R = post.summ(post, "R[")#
S = post.summ(post, "S[")#
N = post.summ(post, "N[")#
U = post.summ(post, "U[")#
resid = post.summ(post, "log.resid[")#
PP = post.summ(post, "pi[")#
alpha = post.summ(post, "alpha")#
beta = post.summ(post, "beta")#
phi = post.summ(post, "phi")#
sigma = post.summ(post, "sigma.R")#
S.msy = post.summ(post, "S.msy")#
S.eq = post.summ(post, "S.eq")#
S.max = post.summ(post, "S.max")#
U.msy = post.summ(post, "U.msy")#
round(rbind(alpha, beta, sigma, phi, S.msy, S.eq, S.max, U.msy), 2)#
quantile(mypost[,'beta'],c(0.025,0.5,0.975))
PP
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0.2),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T)
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0.2),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,scol="dark grey")
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0.2),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey")
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0.8),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey")
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0.4),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey")
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey")
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)
SR_pred <-matrix(NA,100,1000)
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,1000)#
#
for(i in 1:1000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000)#
}
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,1000)#
#
for(i in 1:1000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}
posteriors <- mypost
head(posteriors)
for(i in 1:1000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}
SR_pred
apply(SR_pred,c(2),quantile,probs=c(0.1,0.9),na.rm=T)
apply(SR_pred,c(1),quantile,probs=c(0.1,0.9),na.rm=T)
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)
SR_pred_int
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,1000)#
#
for(i in 1:1000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",col=grey(0.8))
S <- S[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
R <- R[,c(1,12,23,34,42,43,44,45,46,2:11,13:22,24:33,35:41)]#
U <- U[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
N <- N[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
resid <- resid[,c(1,12,23,34,36:39,2:11,13:22,24:33,35)]
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,1000)#
#
for(i in 1:1000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",col=grey(0.8))
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=trans_col.1,border=NA)
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),border=NA)
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])))
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col="light grey")
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,1000)#
#
for(i in 1:1000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col="light grey")#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",col=grey(0.8))
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,1000)#
#
for(i in 1:1000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col="light grey")#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l")
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.2))
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,1000)#
#
for(i in 1:1000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.2))
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)
points(spw/1000, SR_pred_int[2,],type="l")
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,1000)#
#
for(i in 1:1000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.2),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
#
points(spw/1000, SR_pred_int[2,],type="l",col=grey(0.8))#
#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col="light grey",border=NA)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.2),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col="light grey",adjustcolor( "grey", alpha.f = 0.2),lty=2)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col="light grey",adjustcolor( "grey", alpha.f = 0.2),lty=2)
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.2),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col="light grey",adjustcolor( "grey", alpha.f = 0.2),lty=2)
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col="light grey",adjustcolor( "blue", alpha.f = 0.2),lty=2)
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.2),lty=2)
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.2),lty=2,border=F)
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.2),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.2),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")
posteriors <- mypost#
#
jpeg("figures/figure_3_new.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
#BASELINE#
posteriors <- read.csv("outputs/Atnarko_posteriors.baseline.Apr52019.csv")#
forward_sims <- readRDS("outputs/forward_sims_baseline.temp_out.Apr52019")#
forward_res <- readRDS("outputs/forward_sims_baseline.static_out.Apr52019")
# generate plot#
jpeg("figures/Figure_4_revised.baseline.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=2)#
ablineclip(h=4000,lty=2,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,3),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=2,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=3,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
outcomes.sims <- apply(forward_sims,c(1,2,4),quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9),na.rm=T)#
outcomes.res <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
# some housekeeping#
years <- seq(2005,2017)#
#
nms = names(posteriors)#
yy <- posteriors[substr(nms, 1, 2) == "S."]#
spw <- yy[,4:46]#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)#
#
# generate plot#
jpeg("figures/Figure_4_revised.baseline.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=2)#
ablineclip(h=4000,lty=2,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,3),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=2,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=3,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)
outcomes.sims <- apply(forward_sims,c(1,2,4),quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9),na.rm=T)#
outcomes.res <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
# some housekeeping#
years <- seq(2005,2017)#
#
nms = names(posteriors)#
yy <- posteriors[substr(nms, 1, 2) == "S."]#
spw <- yy[,4:46]#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)#
#
# generate plot#
jpeg("figures/Figure_4_revised.baseline.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=2)#
ablineclip(h=4000,lty=3,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,3),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
rm(list = ls())   #
#
source("load.R")
source("figure_2.R")
source("figure_3.R")
library(ggplot2)#
library(tidyverse)#
library(viridis)#
#
age_file <-read.delim("data/age_comps.updatedFeb282019.txt",header=T)#
colnames(age_file) <- c("year","3","4","5","6","samples")#
xxx <- age_file[,-6]#
age_comp <- gather(xxx,age,proportion,c("3","4","5","6"))#
age_file$samples#
#
jpeg("figures/figure_3.jpeg",width=6, height=2.5, units="in",res=800)#
#
ggplot() +#
	geom_bar(aes(x=year,y=proportion*100,fill=age), data = age_comp, stat="identity")+#
	scale_fill_manual(values=viridis(4))+#
	annotate("text", x = 1975:2017, y = 105, label = age_file$samples,size=2.35,angle = 45)+#
	coord_cartesian(ylim=c(4,105),xlim=c(1975,2016))+#
	scale_x_continuous("Year",breaks = c(1975,1985,1995,2005,2015))+ #
	scale_y_continuous("Percent of samples",breaks = c(0,20,40,60,80,100))+#
	theme_bw()+#
	theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"),	#
			 legend.key.size=unit(0.5,"cm"),#
			 panel.border = element_rect(color = "grey", fill=NA, size=0.75))#
#
dev.off()
source("figure_3.R")
source("bayes_sr_model_fit.R")
gelman.diag(post, multivariate = F)
plot.mcmc(post)
library(coda)
plot.mcmc(post)
plot(post)
R = post.summ(post, "R[")#
S = post.summ(post, "S[")#
N = post.summ(post, "N[")#
U = post.summ(post, "U[")#
resid = post.summ(post, "log.resid[")#
PP = post.summ(post, "pi[")#
alpha = post.summ(post, "alpha")#
beta = post.summ(post, "beta")#
phi = post.summ(post, "phi")#
sigma = post.summ(post, "sigma.R")#
S.msy = post.summ(post, "S.msy")#
S.eq = post.summ(post, "S.eq")#
S.max = post.summ(post, "S.max")#
U.msy = post.summ(post, "U.msy")
round(rbind(alpha, beta, sigma, phi, S.msy, S.eq, S.max, U.msy), 2)
quantile(mypost[,'beta'],c(0.025,0.5,0.975))
posteriors <- read.csv("outputs/Atnarko_posteriors.baseline.April302019.csv")
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.April302019")
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.April302019.mcmc")
R = post.summ(sr_model.mcmc, "R[")#
S = post.summ(sr_model.mcmc, "S[")#
resid = post.summ(sr_model.mcmc, "log.resid[")#
#
S <- S[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
R <- R[,c(1,12,23,34,42,43,44,45,46,2:11,13:22,24:33,35:41)]#
resid <- resid[,c(1,12,23,34,36:39,2:11,13:22,24:33,35)]
jpeg("figures/figure_4.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,1]#
	b <- posteriors[r,2]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)
SR_pred_int
b
head()
head(posteriors)
jpeg("figures/figure_4.jpg",width=8, height=3,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=3)#
#
split.screen(rbind(#
c(0,0.40,0,1), #1#
c(0.40,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col="white",yaxt="n",xaxt="n",sfrac=0,gap=0,ylab="Recruits (000s)",xlab="Spawners (000s)",xlim=c(0,65),ylim=c(0,123))#
axis(2,las=2)#
axis(1,las=1,at=c(0,15,30,45,60))#
#
spw=seq(0,70000,length.out=100)#
SR_pred <-matrix(NA,100,10000)#
#
for(i in 1:10000){#
	r <- sample(seq(1,10000),1,replace=T)#
	a <- posteriors[r,2]#
	b <- posteriors[r,3]#
	SR_pred[,i] <- (a*spw*exp(-b*spw))/1000#
}#
#
SR_pred_int <- apply(SR_pred,c(1),quantile,probs=c(0.1,0.5,0.9),na.rm=T)#
polygon(c(spw/1000,rev(spw/1000)),c(SR_pred_int[1,],rev(SR_pred_int[3,])),col=adjustcolor( "grey", alpha.f = 0.3),lty=2)#
#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=R[5,(a.max + 1):nRyrs]/1000,li=R[4,(a.max + 1):nRyrs]/1000,pch=16,col=grey(0),err="y",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T, barcol ="dark grey",cex=0.7)#
plotCI(S[3,1:(Y-a.min)]/1000,R[3,(a.max + 1):nRyrs]/1000,ui=S[5,1:(Y-a.min)]/1000,li=S[4,1:(Y-a.min)]/1000,pch=16,col=grey(0.2),err="x",yaxt="n",xaxt="n",sfrac=0,gap=0,add=T,barcol ="dark grey",cex=0.7)#
#
points(spw/1000, SR_pred_int[2,],type="l",lwd=2)#
text(2,119,"(a)")#
mtext("Spawners (000s)",1,line=2.2)#
box(col="grey")#
#
screen(2)#
#
par( mar=c(3,4,1,0.8),oma=c(0.5,0.5,0.5,0.5))#
#
plot(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",ylim=c(0,20),yaxt="n",ylab="")#
polygon(c(seq(1973,2011),rev(seq(1973,2011))),c(exp(resid[5,]+ 1.052617),rev(exp(resid[4,]+ 1.052617))),col=adjustcolor( "grey", alpha.f = 0.3),lty=2,border=F)#
points(seq(1973,2011),exp(resid[3,]+ 1.052617),type="l",lwd=2)#
axis(2,las=2)#
mtext("Brood year",1,line=2.2)#
mtext("Productivity",2,line=3)#
mtext("(recruits/spawner)",2.1,line=2)#
text(1973,19.5,"(b)")#
abline(h=1,lty=2)#
box(col="grey")#
#
dev.off()
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)#
library(ggplot2)#
library(tidyverse)#
library(viridis)#
library(coda)
#load posterior samples#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.April302019.mcmc")#
posteriors = as.matrix(sr_model.mcmc, chain=F)
# set number of simulations and create array to store results #
num.sims = 1#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}
alpha
beta
Ro
l
w
draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi
out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)
lst.resid
process.iteration(posteriors[draw,])$last_resid
phi
Spw
Rec
mat
sigma.R
samp <- posteriors[draw,]
nms = names(samp)
nms
# parameters#
  alpha = unname(samp[substr(nms, 1, 5) == "alpha"])#
  beta = unname(samp[substr(nms, 1, 5) == "beta"])#
  last_resid = unname(samp[substr(nms, 1, 13) == "log.resid.40."])
last_resid
unname(samp[substr(nms, 1, 13) == "log.resid.40."])
head(posteriors)
nms
as.numeric(samp["S.40."])
samp["S.40."]
posteriors <- sr_model.mcmc
num.sims = 1#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}
posteriors = as.matrix(sr_model.mcmc, chain=F)
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)
samp()
samp(posteriors[draw,])
samp(posteriors[1,])
samp<-(posteriors[1,])
nms = names(samp)
nms
last_resid = unname(samp[substr(nms, 1, 14) == "log.resid.40."])
last_resid
last_resid = unname(samp[substr(nms, 1, 12) == "log.resid.40."])
last_resid
substr(nms, 1, 13) == "log.resid.40."
substr(nms, 1, 5) == "alpha"
substr(nms, 1, 5) == "beta"]
substr(nms, 1, 5) == "beta"
substr(nms, 1, 13) == "log.resid.40."
substr(nms, 1) == "log.resid.40."
substr(nms, 1,15) == "log.resid.40."
substr(nms, 1,20) == "log.resid.40."
substr(nms, 1,20) == "log.resid.1."
substr(nms, 1, 8) == "beta"
samp["pi.2."]
nms
last_resid = unname(samp[substr(nms, 1, 13) == "log.resid[40]"])
last_resid
mat.sch = c(as.numeric(samp["pi[1]"]), as.numeric(samp["pi[2]"]), as.numeric(samp["pi[3]"]), as.numeric(samp["pi[4]"]))
mat.sch
S = c(as.numeric(samp["S[40]"]), as.numeric(samp["S[41]"]), as.numeric(samp["S[42]"]), as.numeric(samp["S[43]"]))
S
## Functions for analysis#
#
#------------------------------------------------------------------------------##
# Posterior summary function#
#------------------------------------------------------------------------------##
post.summ = function(post.samp, var) {#
  post.samp = as.matrix(post.samp)#
  # if parameter is indexed#
  if(substr(var, nchar(var), nchar(var)) == "[") {#
    post = post.samp[,substr(colnames(post.samp), 1, nchar(var)) == var]#
    summ = apply(post, 2, function(x) c(mean = mean(x), sd = sd(x), quantile(x, c(0.5, 0.025, 0.975, 0.1, 0.9, 0.2, 0.8, 0.3, 0.7))))#
    return(summ)#
  }#
  # if parameter is not indexed#
  if(substr(var, nchar(var), nchar(var)) != "[") {#
    post = post.samp[,substr(colnames(post.samp), 1, nchar(var)) == var]#
    summ = c(mean = mean(post), sd = sd(post), quantile(post, c(0.5, 0.025, 0.975)))#
    return(summ)#
  }#
}#
#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years#
# Ro <- the sub-stock recruiment at time zero#
# phi <- the expected correlation through time#
# mat <- stock-specific maturation schedules#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density depedence #
# sigma.R <- recruitment variation#
# U <- finite annual exploitation rate#
# pm.yr <- year of simulation that pms start to be calculated over#
# Rec <- estimated recruitments from last years of empirical data #
# Spw <- estimated spawers from last years of empirical data#
# lst.resid <- estimated recruitment deviation from last year of empirical data#
#
process = function(ny,Ro,phi,mat,U,alpha,beta,sigma.R,Rec,Spw,lst.resid){#
	ns = length(Ro) #number of sub-stocks#
	m.alpha <- alpha#
	m.beta <- beta#
	epi = rnorm(ny, sd= sigma.R)#
#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(0,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	#R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	R[1:3,]=Rec#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot; S = Ntot#
	S[4:7,] = Spw#
	predR = Ntot#
	# populate first few years with realized states#
	R[4,] = exp(log(alpha[]*S[4,]*exp(-beta[]*S[4,])) + phi* lst.resid) * exp(epi[4])#
	v[4,] = log(R[4,])-log(alpha[]*S[4,]*exp(-beta[]*S[4,]))#
	for(i in 5:7){#
		R[i,] = exp(log(alpha[]*S[i,]*exp(-beta[]*S[i,])) + phi* v[i-1,]) * exp(epi[i])#
		v[i,] = log(R[i,])-log(alpha[]*S[i,]*exp(-beta[]*S[i,]))		#
	}#
#
	N[4:7,1,]=R[4:7-(3),] * mat[1]#
	N[5:7,2,]=R[5:7-(4),] * mat[2]#
	N[6:7,3,]=R[6:7-(5),] * mat[3]#
	N[7,4,]=R[7-(6),] * mat[4]#
	# Loop through years of simulation	#
	for(i in (7+1):ny){#
		N[i,1,1] = R[i-(4),1] * mat[1]#
		N[i,2,1] = R[i-(5),1] * mat[2]#
		N[i,3,1] = R[i-(6),1] * mat[3]#
		N[i,4,1] = R[i-(7),1] * mat[4]#
		Ntot[i,1] = sum(N[i,,1])#
#
		# apply harvest #
		H[i,1] =  U*Ntot[i,1]#
		S_exp = Ntot[i,1]-H[i,1] ; S_exp[S_exp<0] = 0#
		S[i,1] = S_exp#
		# predict recruitment#
		R[i,1] = alpha[]*S[i,1]*exp(-beta[]*S[i,1]+phi*v[i-1,1]+epi[i])#
		predR[i,] = alpha[]*S[i,1]*exp(-beta[]*S[i,1])#
		v[i,1] = log(R[i,1])-log(predR[i,1])#
		v[v[,1]=='NaN'] <- 0#
	  }#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	p_rg <-ifelse(median(S[(ny-10):ny,])>15000,1,0)#
	p_lrp <-ifelse(median(S[(ny-10):ny,])>4000,1,0)#
	list(S=S[,],N=Ntot[,],survival=as.numeric(v),P=c(p_rg,p_lrp))#
	}#
#
#------------------------------------------------------------------------------##
# Function to sample from posteriors for forward simulations#
#------------------------------------------------------------------------------#	#
#
process.iteration = function(samp) {#
  # 1.) extract names#
  nms = names(samp)#
  # 2.) extract elements according to the names and put them into the appropriate data structure#
  # parameters#
  alpha = unname(samp[substr(nms, 1, 5) == "alpha"])#
  beta = unname(samp[substr(nms, 1, 5) == "beta"])#
  last_resid = unname(samp[substr(nms, 1, 13) == "log.resid[40]"])#
  phi = unname(samp["phi"])#
  sigma_R = unname(samp["sigma.R"])#
  mat.sch = c(as.numeric(samp["pi[1]"]), as.numeric(samp["pi[2]"]), as.numeric(samp["pi[3]"]), as.numeric(samp["pi[4]"]))#
  # states#
  S = c(as.numeric(samp["S[40]"]), as.numeric(samp["S[41]"]), as.numeric(samp["S[42]"]), as.numeric(samp["S[43]"]))#
  R = c(as.numeric(samp["R[44]"]), as.numeric(samp["R[45]"]), as.numeric(samp["R[46]"]))#
  # 3.) create output list#
  output = list(#
    alpha = as.numeric(alpha),#
    beta = as.numeric(beta),#
    phi = as.numeric(phi),#
    last_resid = as.numeric(last_resid),#
    sigma_R = as.numeric(sigma_R),#
    mat.sch = mat.sch,#
    S = S,#
    R = R#
    )#
#
  # 4.) return output#
  return(output)#
#
}
# set number of simulations and create array to store results #
num.sims = 1#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(grDevices)#
library(plotrix)#
library(R2jags) #
library(modeest) #
library(gplots)#
library(ggplot2)#
library(tidyverse)#
library(viridis)#
library(coda)
#------------------------------------------------------------------------------##
# Run closed loop simulations across a range of harves rates#
#------------------------------------------------------------------------------##
#
#load posterior samples#
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.April302019.mcmc")#
posteriors = as.matrix(sr_model.mcmc, chain=F)#
#
# set number of simulations and create array to store results #
num.sims = 1000#
ny = 27 #(7 years plus length of forward sim)#
harvest_rate <- seq(0,0.4,length.out=21)#
temporal.outcomes <- array(NA,dim=c(ny,3,num.sims,length(harvest_rate)))#
static.outcomes <- array(NA,dim=c(1,2, num.sims,length(harvest_rate)))#
#
# set conditions for simulation function#
alpha <- process.iteration(posteriors[1,])$alpha#
beta <- process.iteration(posteriors[1,])$beta#
Ro <- log(alpha)/beta; sum(Ro)#
#
ptm <- proc.time()#
#
# run simulations!#
for (w in 1:length(harvest_rate)){#
	for (l in 1: num.sims){#
		draw <- sample(10000,1)#
		alpha <- process.iteration(posteriors[draw,])$alpha#
		beta <- process.iteration(posteriors[draw,])$beta#
		sigma.R <- process.iteration(posteriors[draw,])$sigma_R#
		mat <- process.iteration(posteriors[draw,])$mat.sch#
		Rec <- process.iteration(posteriors[draw,])$R#
		Spw <- process.iteration(posteriors[draw,])$S#
		lst.resid <- process.iteration(posteriors[draw,])$last_resid#
		phi <- process.iteration(posteriors[draw,])$phi#
		out <- process(ny,Ro,phi,mat,harvest_rate[w],alpha,beta,sigma.R,Rec,Spw,lst.resid)#
		temporal.outcomes[,1,l,w] <- out$S#
		temporal.outcomes[,2,l,w] <- out$N#
		temporal.outcomes[,3,l,w] <- out$survival#
		static.outcomes[,1,l,w] <- out$P[1]#
		static.outcomes[,2,l,w] <- out$P[2]#
	}	#
}#
saveRDS(temporal.outcomes,"outputs/forward_sims_baseline.temp_out.Apr302019")  #
saveRDS(static.outcomes,"outputs/forward_sims_baseline.static_out.Apr302019")  #
(proc.time() - ptm)/60
static.outcomes
temporal.outcomes
saveRDS(temporal.outcomes,"outputs/forward_sims_baseline.temp_out.Apr302019")  #
saveRDS(static.outcomes,"outputs/forward_sims_baseline.static_out.Apr302019")
source("figure_5.R")
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.April302019.mcmc")#
posteriors = as.matrix(sr_model.mcmc, chain=F)
forward_sims <- readRDS("outputs/forward_sims_baseline.temp_out.Apr302019")#
forward_res <- readRDS("outputs/forward_sims_baseline.static_out.Apr302019")
outcomes.sims <- apply(forward_sims,c(1,2,4),quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9),na.rm=T)#
outcomes.res <- apply(forward_res,c(1,2,4),mean,na.rm=T)#
#
# some housekeeping#
years <- seq(2005,2017)#
#
nms = names(posteriors)#
yy <- posteriors[substr(nms, 1, 2) == "S."]#
spw <- yy[,4:46]#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)
yy <- posteriors[substr(nms, 1, 2) == "S[]"]
spw <- yy[,4:46]
yy
nms = names(posteriors)#
yy <- posteriors[substr(nms, 1, 2) == "S["]
spw <- yy[,4:46]
yy
nms
nms = names(posteriors)
nms
sr_model.mcmc <- readRDS("outputs/Atnarko_posteriors.baseline.April302019.mcmc")
posteriors = as.matrix(sr_model.mcmc, chain=F)
nms = names(posteriors)
nms
posteriors
head(posteriors)
nms = names(posteriors)
nms
nms = names(sr_model.mcmc)
nms
dimnames(posteriors)
nms = dimnames(posteriors)
nms
yy <- posteriors[substr(nms, 1, 2) == "S["]
yy
yy <- posteriors[substr(nms, 1, 3) == "S["]
yy
yy <- posteriors[substr(nms, 1, 1) == "S["]
yy
yy <- posteriors[substr(nms, 1, 2) = "S["]
yy <- posteriors[substr(nms, 1, 2) == "S["]
yy
head(posteriors)
yy <- posteriors[,593:630]
HEAD(yy)
head(yy)
spw <- posteriors[,593:630]#
#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)
head(spw)
nms
spw <- posteriors[,593:635]#
#
S <- spw[,c(1,12,23,34,39:43,2:11,13:22,24:33,35:38)]#
S.summ <- apply(S,2,quantile,probs=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9))#
#
S.summ[5,43] <- outcomes.sims[5,7,1,1]#
#
trans_col.1<-rgb(0,0,255,max=255,alpha=15)#
trans_col.2<-rgb(0,255,0,max=255,alpha=35)#
trans_col.3<-rgb(255,0,0,max=255,alpha=35)#
#
harvest_rate <- seq(0,0.4,length.out=21)
# generate plot#
jpeg("figures/Figure_5.jpeg",width=8, height=3.5,units="in",res=400,bg = "transparent")#
#dev.new(width=8, height=4)#
par(new=T)#
#
split.screen(rbind(#
c(0,0.55,0,1), #1#
c(0.57,1,0,1) #2#
))#
#
screen(1)#
#
par(mar=c(3,3,1,0.8),oma=c(1,0.5,0.5,0.5))#
#
plot(years,S.summ[5,31:43],type="l",lwd=2,ylim=c(0,100000),xlim=c(2010,2036.5),yaxt="n",xaxt="n")#
axis(2,las=2,at=c(0,20000,40000,60000,80000,100000),labels=c("0","20","40","60","80","100"),cex.axis=0.9)#
axis(1,at=c(2005,2015,2025,2035), cex.axis =0.9)#
#
mtext("Spawners (000s)",2,line=2.2,cex=1)#
mtext("Year",1,line=2.1,cex=1)#
#
ablineclip(lty=2,col="dark green",x1=2017,x2=2037,y1=15000,h=15000,lwd=2)#
ablineclip(h=4000,lty=3,col="red",x1=2017,x2=2037,lwd=2)#
#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[1,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[2,7:27,1,10],rev(outcomes.sims[8,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[3,7:27,1,10],rev(outcomes.sims[7,7:27,1,10])),col=trans_col.1,border=NA)#
polygon(c(seq(2017,2037),rev(seq(2017,2037))),c(outcomes.sims[4,7:27,1,10],rev(outcomes.sims[9,7:27,1,10])),col=trans_col.1,border=NA)#
points(seq(2017,2037),outcomes.sims[5,7:27,1,10],type="l",col="blue",lwd=2)#
#
polygon(c(years,rev(years)),c(S.summ[1,31:43],rev(S.summ[9,31:43])),col=grey(0.8),border=NA)#
polygon(c(years,rev(years)),c(S.summ[2,31:43],rev(S.summ[8,31:43])),col=grey(0.7),border=NA)#
polygon(c(years,rev(years)),c(S.summ[3,31:43],rev(S.summ[7,31:43])),col=grey(0.6),border=NA)#
polygon(c(years,rev(years)),c(S.summ[4,31:43],rev(S.summ[6,31:43])),col=grey(0.5),border=NA)#
points(years,S.summ[5,31:43],type="l",lwd=2)#
#
text(2009,96000,"(a)",pos=4)#
#
legend(2009,90000,legend=c("Recovery goal","Limit reference point"),lty=c(2,3),lwd=2,col=c("dark green","red"),text.col=c("dark green","red"),bty="n",cex=0.8)#
#
box(col="grey")#
#
screen(2)#
#
par(mar=c(3,3,1,0),oma=c(1,1,0.5,0.25))#
#
plot(harvest_rate ,outcomes.res[,2,]*100,yaxt="n",ylab=,xaxt="n",ylim=c(0,100),type="l",lwd=2,lty=3,col="red")#
points(harvest_rate ,outcomes.res[,1,]*100,lwd=2,type="l",lty=2,col="dark green")#
#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,2,]*100,rev(outcomes.res[,1,]*100)),col=trans_col.3,border=NA)#
polygon(c(harvest_rate,rev(harvest_rate)),c(outcomes.res[,1,]*100,seq(0,0,length.out=length(outcomes.res[,1,]*100))),col=trans_col.2,border=NA)#
axis(2,las=2, cex.axis =0.9)#
axis(1,at=c(0,0.1,0.2,0.3,0.4),labels=c("0","10","20","30","40"), cex.axis =0.9)#
mtext("Chance of exceeding limit ",2,line=3.35)#
mtext("reference point / recovery goal (%)",2,line=2.35)#
mtext("Harvest rate (%)",1,line=2)#
text(0.015,96,"(b)")#
box(col="grey")#
#
dev.off()
source("figure_5.R")
source("samp_sims_figure6_7.R")
source("load.R")
source("samp_sims_figure6_7.R")
jpeg(filename = "figures/figure_6.jpeg",#
     width = 2600, height = 1500, units = "px", pointsize = 9,#
     bg = "white", res = 600)#
#
samples<-c(60,120,240,360,600)#
#
par(mfrow=c(1,2))    #
par(mar=c(2,1,1,0),oma=c(2,4,1,1))#
### single sample#
for(i in 1:10){#
  plot(comp.var[i,1:5],type="l",ylim=c(0,1.6),axes=FALSE,xlab="",ylab="",col= colors[i])#
  par(new=TRUE)#
}#
plot(comp.equal[,1],type="l",las=1,xlab="",ylab="",lwd=2,ylim=c(0,1.6),axes=FALSE)    #
#
axis(1,at=c(1,2,3,4,5),labels=samples,cex.axis=0.9)#
axis(2,las=1,at=c(0,0.5,1.0,1.5,2.0),cex.axis=0.9)#
text(2.5,1.55,"(a) annual sampling",cex=0.8)#
text(4,0.83,"smallest population",cex=0.55, col=colors[1])#
text(4,0.10,"largest population",cex=0.55, col=colors[10])#
mtext(side=2,"Catch composition",line=3.5)#
mtext(side=2,"uncertainty (CV)",adj=0.5,line=2.5)#
mtext(side=1,"Number of samples",line=0.5,outer=T)#
box(col="grey")#
#
### weekly sample#
for(i in 1:10){#
  plot(comp.var[i,6:10],type="l",ylim=c(0,1.6),axes=FALSE,xlab="",ylab="",col=colors[i])#
  par(new=TRUE)#
}#
plot(comp.equal[,2],type="l",las=1,xlab="",ylab="",lwd=2,ylim=c(0,1.6),axes=FALSE)   #
text(2.5,1.55,"(b) weekly sampling",cex=0.8)#
#
axis(1,at=c(1,2,3,4,5),labels=samples,cex.axis=0.9)#
axis(2,las=1,at=c(0,0.5,1.0,1.5,2.0),labels=FALSE)#
box(col="grey")#
#
dev.off()  #
#
##########################################################
#### plotting harvest rate data#
#
harv.equal<-matrix(nrow=5,ncol=10)#
#
rate.yr1.0#
rate.yr3.0#
#
for(i in 1:5){#
harv.equal[i,1]<-mean(rate.yr1.0[,4,i])#
harv.equal[i,2]<-mean(rate.yr3.0[,4,i])#
harv.equal[i,3]<-mean(rate.yr1.1[,4,i])#
harv.equal[i,4]<-mean(rate.yr3.1[,4,i])#
harv.equal[i,5]<-mean(rate.yr1.2[,4,i])#
harv.equal[i,6]<-mean(rate.yr3.2[,4,i])#
harv.equal[i,7]<-mean(rate.yr1.3[,4,i])#
harv.equal[i,8]<-mean(rate.yr3.3[,4,i])#
harv.equal[i,9]<-mean(rate.yr1.4[,4,i])#
harv.equal[i,10]<-mean(rate.yr3.4[,4,i])#
}#
#
harv.var<-array(dim=c(5,15,2))#
#
harv.var[,,1]                #
for(i in 1:5){#
  harv.var[i,1,1]<-rate.yr2.0[1,4,i]#
  harv.var[i,2,1]<-rate.yr2.0[9,4,i]#
  harv.var[i,3,1]<-mean(rate.yr2.0[,4,i])#
  harv.var[i,4,1]<-rate.yr2.1[1,4,i]#
  harv.var[i,5,1]<-rate.yr2.1[9,4,i]#
  harv.var[i,6,1]<-mean(rate.yr2.1[,4,i])#
  harv.var[i,7,1]<-rate.yr2.2[1,4,i]#
  harv.var[i,8,1]<-rate.yr2.2[9,4,i]#
  harv.var[i,9,1]<-mean(rate.yr2.2[,4,i])#
  harv.var[i,10,1]<-rate.yr2.3[1,4,i]#
  harv.var[i,11,1]<-rate.yr2.3[9,4,i]#
  harv.var[i,12,1]<-mean(rate.yr2.3[,4,i]) #
  harv.var[i,13,1]<-rate.yr2.4[1,4,i]#
  harv.var[i,14,1]<-rate.yr2.4[9,4,i]#
  harv.var[i,15,1]<-mean(rate.yr2.4[,4,i]) #
#
}#
for(i in 1:5){#
  harv.var[i,1,2]<-rate.yr4.0[1,4,i]#
  harv.var[i,2,2]<-rate.yr4.0[9,4,i]#
  harv.var[i,3,2]<-mean(rate.yr4.0[,4,i])#
  harv.var[i,4,2]<-rate.yr4.1[1,4,i]#
  harv.var[i,5,2]<-rate.yr4.1[9,4,i]#
  harv.var[i,6,2]<-mean(rate.yr4.1[,4,i])#
  harv.var[i,7,2]<-rate.yr4.2[1,4,i]#
  harv.var[i,8,2]<-rate.yr4.2[9,4,i]#
  harv.var[i,9,2]<-mean(rate.yr4.2[,4,i])#
  harv.var[i,10,2]<-rate.yr4.3[1,4,i]#
  harv.var[i,11,2]<-rate.yr4.3[9,4,i]#
  harv.var[i,12,2]<-mean(rate.yr4.3[,4,i]) #
  harv.var[i,13,2]<-rate.yr4.4[1,4,i]#
  harv.var[i,14,2]<-rate.yr4.4[9,4,i]#
  harv.var[i,15,2]<-mean(rate.yr4.4[,4,i]) #
}#
jpeg(filename = "figures/figure_7.jpeg",#
     width = 2400, height = 2400, units = "px", pointsize = 9,#
     bg = "white", res = 600)#
#
colors<-viridis(5)#
colors1<-viridis(3)#
colors2<-viridis(3, alpha=0.2)#
single<-c(1,3,5,7,9)#
week<-c(2,4,6,8,10)#
#
par(mfrow=c(2,2))#
par(mar=c(0,1,1,0),oma=c(4,4,1,1))#
#
for(i in 1:5){#
  plot(harv.equal[,single[i]],type="l",ylim=c(0,1.5),xlim=c(1,5),axes=FALSE,xlab="",ylab="",col=colors[i],lwd=2)#
  par(new=TRUE)#
#
}#
plot(1,cex=0,axes=FALSE,xlab="",ylab="",ylim=c(0,1.5),xlim=c(1,5))#
axis(1,at=c(1,2,3,4,5),labels=FALSE)#
axis(2,las=2,at=c(0,0.5,1,1.5,2))#
mtext(side=3,"Annual sampling", cex=1,adj=0.5)#
text(1.25,1.45,"(a)")#
mtext(side=2,"Harvest rate uncertianty (CV)",line=2.5,outer=T)#
box(col="grey")#
#
legend("topright", title="",pch=15,c("No observation error","Catch CV = 0.2; Size CV = 0.2","Catch CV = 0.2; Size CV = 0.5","Catch CV = 0.5; Size CV = 0.2","Catch CV = 0.5; Size CV = 0.5"),col=colors,cex=0.70,inset=0.03,bty="n")#
#
for(i in 1:5){#
  plot(harv.equal[,week[i]],type="l",ylim=c(0,1.5),xlim=c(1,5),axes=FALSE,xlab="",ylab="",col=colors[i],lwd=2)#
  par(new=TRUE)#
}#
plot(1,cex=0,axes=FALSE,xlab="",ylab="",ylim=c(0,1.5),xlim=c(1,5))#
axis(1,at=c(1,2,3,4,5),labels=FALSE)#
axis(2,las=2,at=c(0,0.5,1,1.5,2),labels=FALSE)#
mtext(side=3,"Weekly sampling", cex=1,adj=0.5)#
text(1.25,1.45,"(b)")#
box(col="grey")#
#
#### annual sampling variable population size#
gr<-c(1,4,13)#
#
for (i in 1:3){#
  for(j in 0:1){#
    plot(harv.var[,gr[i]+j,1],ylim=c(0,1.8),type="l",col=colors1[i],axes=FALSE,xlab="",ylab="",lty=2)#
    par(new=TRUE)#
    plot(harv.var[,gr[i]+2,1],ylim=c(0,1.8),type="l",col=colors1[i],axes=FALSE,xlab="",ylab="",lwd=2)#
    polygon(c(seq(1,5),rev(seq(1,5))),c(harv.var[,gr[i]+j,1],rev(harv.var[,gr[i]+2,1])),col=colors2[i],border=NA)#
    par(new=TRUE)#
    }#
}#
#
harv.var#
#
plot(1,cex=0,axes=FALSE,xlab="",ylab="",ylim=c(0,1.8),xlim=c(1,5))#
axis(1,at=c(1,2,3,4,5),labels=c(60,120,240,360,600))#
axis(2,las=2,at=c(0,0.5,1,1.5,2),labels=c(0,0.5,1,1.5,2))#
text(1.25,1.75,"(c)")#
mtext(side=1,"Number of samples",outer=T,line=2.5)#
box(col="grey")#
#
#### weekly sampling variable population size#
for (i in 1:3){#
  for(j in 0:1){#
    plot(harv.var[,gr[i]+j,2],ylim=c(0,1.8),type="l",col=colors1[i],axes=FALSE,xlab="",ylab="",lty=2)#
    par(new=TRUE)#
    plot(harv.var[,gr[i]+2,2],ylim=c(0,1.8),type="l",col=colors1[i],axes=FALSE,xlab="",ylab="",lwd=2)#
    polygon(c(seq(1,5),rev(seq(1,5))),c(harv.var[,gr[i]+j,2],rev(harv.var[,gr[i]+2,2])),col=colors2[i],border=NA)#
    par(new=TRUE)#
  }#
}#
#
plot(1,cex=0,axes=FALSE,xlab="",ylab="",ylim=c(0,1.8),xlim=c(1,5))#
axis(1,at=c(1,2,3,4,5),labels=c(60,120,240,360,600))#
axis(2,las=2,at=c(0,0.5,1,1.5,2),labels=FALSE)#
text(1.25,1.75,"(d)")#
box(col="grey")#
#
dev.off()
